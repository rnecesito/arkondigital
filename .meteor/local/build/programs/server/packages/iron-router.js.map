{"version":3,"file":"/packages/iron-router.js","sources":["iron-router/license.js","iron-router/lib/router_utils.js","iron-router/lib/route_path.js","iron-router/lib/route_context.js","iron-router/lib/route.js","iron-router/lib/route_controller.js","iron-router/lib/router.js","iron-router/lib/server/route_controller.js","iron-router/lib/server/server_router.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,qB;;AAEA,wD;;AAEA,4E;AACA,6E;AACA,4E;AACA,yE;AACA,qE;AACA,wD;;AAEA,0E;AACA,mD;;AAEA,0E;AACA,wE;AACA,2E;AACA,sE;AACA,6E;AACA,yE;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;ACtBA,G;AACA,sD;AACA,G;;AAEA,iB;;AAEA,G;AACA,mD;AACA,G;;AAEA,kC;AACA,oC;AACA,kB;AACA,yC;AACA,kB;AACA,M;AACA,gB;AACA,E;;AAEA,G;AACA,8E;AACA,+E;AACA,e;AACA,E;AACA,Y;AACA,uD;AACA,+D;AACA,E;AACA,qC;AACA,G;;AAEA,mD;AACA,mC;AACA,W;AACA,U;;AAEA,gC;AACA,kC;AACA,iB;AACA,4C;AACA,0B;AACA,e;AACA,6E;AACA,K;AACA,U;AACA,sB;AACA,G;;AAEA,uD;AACA,a;AACA,E;;AAEA,kD;AACA,+B;AACA,6B;AACA,E;;AAEA,G;AACA,uE;AACA,4E;AACA,+E;AACA,yD;AACA,G;;AAEA,iD;AACA,wD;AACA,kF;AACA,G;AACA,yD;AACA,mF;;AAEA,2B;AACA,gD;AACA,+B;AACA,G;;AAEA,oB;AACA,6B;AACA,G;;AAEA,oC;AACA,+B;AACA,qC;AACA,e;AACA,E;;AAEA,sC;AACA,W;AACA,c;AACA,wD;AACA,iB;AACA,M;AACA,e;AACA,E;;AAEA,qC;AACA,0B;AACA,wB;AACA,M;AACA,+C;AACA,E;;AAEA,mD;AACA,6B;AACA,uB;AACA,Q;AACA,kC;AACA,8B;AACA,G;;AAEA,mE;AACA,E;;AAEA,qD;AACA,iB;AACA,gB;AACA,qB;;AAEA,0B;AACA,gC;;AAEA,4D;AACA,yC;AACA,Q;AACA,+B;AACA,qE;AACA,wE;AACA,K;AACA,G;;AAEA,iC;;AAEA,kD;;AAEA,oD;AACA,iE;AACA,wD;AACA,I;;AAEA,mB;AACA,qC;AACA,G;;AAEA,8C;;AAEA,qB;AACA,E;;AAEA,G;AACA,6C;AACA,E;AACA,2E;AACA,2E;AACA,G;;AAEA,gD;AACA,iB;AACA,yB;AACA,E;;AAEA,yC;AACA,yD;AACA,E;;AAEA,uC;AACA,oB;AACA,+C;AACA,wC;AACA,c;AACA,E;;AAEA,G;AACA,8E;AACA,2E;AACA,wE;AACA,iC;AACA,E;AACA,yE;AACA,mB;AACA,2E;AACA,+C;AACA,sB;AACA,e;AACA,G;;AAEA,8D;AACA,sB;;AAEA,yB;AACA,oB;AACA,4B;AACA,8B;;AAEA,6B;AACA,yB;;AAEA,oE;AACA,kB;AACA,C;;;;;;;;;;;;;;;;;;;ACtMA,G;AACA,U;AACA,E;AACA,8E;AACA,yE;AACA,2E;AACA,6E;AACA,yE;AACA,E;AACA,G;;AAEA,G;AACA,0E;AACA,+D;AACA,E;AACA,Y;AACA,Y;AACA,iB;AACA,gC;AACA,iC;AACA,c;AACA,qB;AACA,gC;AACA,E;AACA,0B;AACA,+B;AACA,6B;AACA,iE;AACA,2D;AACA,gB;AACA,G;;AAEA,sC;AACA,2C;AACA,yE;;AAEA,iB;AACA,yB;AACA,+B;AACA,E;;AAEA,uB;AACA,wB;;AAEA,yB;;AAEA,K;AACA,6E;AACA,4C;AACA,I;AACA,yB;AACA,iB;AACA,K;;AAEA,wB;AACA,mB;AACA,Y;AACA,+B;;AAEA,sC;AACA,0B;AACA,Y;AACA,sB;AACA,2C;AACA,iC;AACA,iB;AACA,iD;AACA,kE;AACA,iE;AACA,gC;AACA,qB;AACA,uC;AACA,qB;AACA,uC;AACA,+B;AACA,wE;AACA,iC;AACA,W;AACA,S;AACA,oC;AACA,gC;AACA,M;AACA,2E;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,0E;AACA,8C;AACA,I;AACA,yB;AACA,oB;AACA,gB;AACA,K;;AAEA,2B;AACA,2B;;AAEA,mB;AACA,2B;AACA,mB;AACA,wB;AACA,W;AACA,c;;AAEA,mD;AACA,wB;AACA,wE;AACA,gB;AACA,4D;AACA,mC;AACA,Y;AACA,2B;AACA,K;;AAEA,gD;;AAEA,sB;AACA,6D;AACA,4C;AACA,kE;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,K;AACA,0D;AACA,I;AACA,yB;AACA,uB;AACA,gB;AACA,K;AACA,yB;AACA,mC;AACA,4D;AACA,I;AACA,kC;AACA,I;;AAEA,K;AACA,8E;AACA,gB;AACA,I;AACA,yB;AACA,yB;AACA,gB;AACA,K;AACA,yB;AACA,mC;AACA,4D;AACA,kC;AACA,I;;AAEA,K;AACA,+E;AACA,gF;AACA,6D;AACA,I;AACA,iC;AACA,6E;AACA,c;AACA,qB;AACA,gB;AACA,K;AACA,8B;AACA,a;AACA,sB;AACA,c;AACA,yB;AACA,wB;AACA,c;;AAEA,0B;AACA,yB;;AAEA,iC;AACA,4E;AACA,Y;AACA,sB;AACA,iB;AACA,iD;AACA,mE;AACA,gC;AACA,gC;AACA,0D;;AAEA,8C;AACA,yB;AACA,yB;AACA,yC;AACA,4D;AACA,a;;AAEA,qE;AACA,qD;AACA,W;AACA,S;AACA,iB;AACA,gB;AACA,4B;AACA,+D;AACA,8B;AACA,6E;AACA,+B;AACA,uE;AACA,a;;AAEA,+D;AACA,W;AACA,U;;AAEA,kB;AACA,gC;AACA,8D;AACA,yE;AACA,uB;AACA,S;;AAEA,kC;AACA,O;AACA,K;AACA,I;AACA,gB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACpOA,G;AACA,6E;AACA,yE;AACA,8E;AACA,kC;AACA,E;AACA,4B;AACA,uB;AACA,6B;AACA,uB;AACA,4B;AACA,e;AACA,G;;AAEA,wD;AACA,uF;AACA,6F;AACA,qE;;AAEA,wC;AACA,mC;AACA,sB;AACA,mB;AACA,uB;AACA,qB;AACA,6B;AACA,mC;AACA,sC;AACA,qC;AACA,qC;AACA,E;;AAEA,0B;AACA,2B;;AAEA,4B;;AAEA,K;AACA,6E;AACA,0D;AACA,I;AACA,sB;AACA,gB;AACA,K;;AAEA,yB;AACA,qC;AACA,qB;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AClDA,G;AACA,yC;AACA,E;AACA,Y;AACA,yD;AACA,yE;AACA,kF;AACA,E;AACA,qB;AACA,iB;AACA,6B;AACA,4E;AACA,oE;AACA,4B;AACA,iC;AACA,sC;AACA,yE;AACA,4E;AACA,yC;AACA,c;AACA,G;;AAEA,mD;AACA,W;;AAEA,mD;;AAEA,sC;AACA,iE;;AAEA,4B;AACA,mC;;AAEA,4B;AACA,8B;;AAEA,yC;AACA,sC;;AAEA,uB;AACA,2B;AACA,6D;AACA,mB;AACA,yC;AACA,iD;AACA,+B;AACA,uC;;AAEA,8C;AACA,uC;AACA,M;AACA,2B;AACA,E;;AAEA,mB;AACA,oB;;AAEA,qB;;AAEA,K;AACA,+E;AACA,sD;AACA,I;AACA,yB;AACA,sB;AACA,gB;AACA,K;;AAEA,yB;AACA,wC;AACA,I;;AAEA,K;AACA,gF;AACA,qC;AACA,I;AACA,yB;AACA,2B;AACA,gB;AACA,K;;AAEA,2B;AACA,0C;AACA,I;;AAEA,K;AACA,4E;AACA,qC;AACA,I;AACA,a;AACA,kE;AACA,uC;AACA,I;AACA,iC;AACA,qB;AACA,gB;AACA,K;;AAEA,2B;AACA,6C;AACA,I;;AAEA,K;AACA,iE;AACA,2C;AACA,I;AACA,a;AACA,kE;AACA,gE;AACA,I;AACA,iC;AACA,qB;AACA,gB;AACA,K;;AAEA,0B;AACA,iC;AACA,wB;AACA,wC;AACA,uC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACzHA,G;AACA,gE;AACA,E;AACA,+B;AACA,2B;AACA,gC;AACA,4B;AACA,8C;AACA,qD;AACA,sD;AACA,0C;AACA,G;;AAEA,+C;AACA,mB;AACA,kB;AACA,kB;;AAEA,yE;;AAEA,yC;;AAEA,mE;AACA,gE;;AAEA,qC;AACA,6B;AACA,+B;AACA,yB;;AAEA,kC;AACA,wB;AACA,2B;AACA,6B;AACA,oB;AACA,I;;AAEA,iD;AACA,+C;AACA,qD;AACA,mD;;AAEA,uB;AACA,yB;;AAEA,kB;AACA,sD;AACA,qD;AACA,gD;AACA,8C;;AAEA,iB;AACA,qD;AACA,oD;AACA,+C;AACA,6C;;AAEA,oC;AACA,E;;AAEA,6B;AACA,8B;;AAEA,+B;;AAEA,2C;AACA,uC;AACA,I;;AAEA,a;;AAEA,K;AACA,8E;AACA,+E;AACA,+E;AACA,+E;AACA,uD;AACA,K;;AAEA,Y;;AAEA,K;AACA,yD;AACA,I;AACA,0E;AACA,gB;AACA,K;;AAEA,6B;AACA,mB;AACA,2B;;AAEA,uB;;AAEA,4C;AACA,8B;AACA,0B;AACA,K;AACA,I;;;AAGA,K;AACA,gF;AACA,4E;AACA,qB;AACA,I;AACA,gB;AACA,K;;AAEA,oB;AACA,uC;AACA,I;;AAEA,K;AACA,gF;AACA,wB;AACA,I;AACA,gB;AACA,K;;AAEA,mC;AACA,gB;AACA,wD;AACA,I;AACA,E;AACA,K;AACA,gF;AACA,gF;AACA,+E;AACA,uE;AACA,I;AACA,gB;AACA,K;AACA,oB;AACA,wB;AACA,I;;AAEA,K;AACA,0E;AACA,0E;AACA,mE;AACA,I;AACA,gB;AACA,K;;AAEA,4B;AACA,I;;AAEA,K;AACA,kE;AACA,0E;AACA,mE;AACA,I;AACA,gB;AACA,K;;AAEA,2B;AACA,I;;AAEA,K;AACA,+D;AACA,I;AACA,gB;AACA,K;;AAEA,8B;AACA,I;;AAEA,K;AACA,8D;AACA,I;AACA,gB;AACA,K;;AAEA,6B;AACA,G;AACA,E;;AAEA,2B;AACA,K;AACA,iC;AACA,I;AACA,yE;AACA,K;;AAEA,iC;AACA,gD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC5LA,G;AACA,8D;AACA,E;AACA,0B;AACA,sB;AACA,4B;AACA,c;AACA,G;;AAEA,iC;AACA,0B;;AAEA,K;AACA,oE;AACA,6B;AACA,I;AACA,gB;AACA,K;AACA,mB;;AAEA,K;AACA,6E;AACA,uE;AACA,I;AACA,iB;AACA,K;AACA,uB;;AAEA,K;AACA,sD;AACA,I;AACA,iB;AACA,K;AACA,mC;AACA,E;;;AAGA,wB;AACA,yB;;AAEA,0B;;AAEA,K;AACA,4E;AACA,wE;AACA,I;AACA,4B;AACA,yB;AACA,gB;AACA,K;;AAEA,iC;AACA,sC;AACA,oC;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,+C;AACA,I;AACA,a;AACA,8B;AACA,4B;AACA,S;AACA,I;AACA,0B;AACA,0B;AACA,iB;AACA,K;;AAEA,sB;AACA,wC;AACA,6D;AACA,kB;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,iE;AACA,I;AACA,+C;AACA,iE;AACA,+E;AACA,gF;AACA,uD;AACA,oB;AACA,gB;AACA,K;;AAEA,4C;AACA,c;;AAEA,yE;AACA,I;AACA,iC;AACA,sB;AACA,Q;AACA,sD;;AAEA,8B;AACA,4B;AACA,iB;AACA,I;;AAEA,K;AACA,+E;AACA,6B;AACA,I;AACA,a;AACA,qD;AACA,8D;AACA,yB;AACA,K;AACA,4D;AACA,iC;AACA,qB;AACA,gB;AACA,K;;AAEA,mC;AACA,sC;AACA,8C;AACA,4I;AACA,+C;AACA,I;;AAEA,K;AACA,wE;AACA,uC;AACA,I;AACA,a;AACA,qD;AACA,6D;AACA,mD;AACA,K;;AAEA,qC;AACA,yF;AACA,8C;AACA,I;;AAEA,K;AACA,2E;AACA,qE;AACA,gF;AACA,yE;AACA,qD;AACA,I;AACA,8C;AACA,wE;AACA,sE;AACA,0E;AACA,iC;AACA,gF;AACA,yE;AACA,+C;AACA,yB;AACA,gB;AACA,K;;AAEA,uD;AACA,mB;AACA,4B;AACA,a;AACA,qD;AACA,c;;AAEA,sB;AACA,0B;AACA,oD;;AAEA,mB;AACA,mD;AACA,O;;AAEA,6B;AACA,mC;AACA,4C;AACA,wD;AACA,oB;AACA,K;;AAEA,W;AACA,gB;AACA,I;;AAEA,K;AACA,8E;AACA,0E;AACA,8E;AACA,mF;AACA,6E;AACA,gF;AACA,gF;AACA,+E;AACA,mD;AACA,I;AACA,yB;AACA,yB;AACA,8B;AACA,sE;AACA,0E;AACA,iC;AACA,gF;AACA,yE;AACA,+C;AACA,yB;AACA,gB;AACA,K;;AAEA,yD;AACA,mB;AACA,e;AACA,kB;AACA,sD;;AAEA,yD;AACA,4E;;AAEA,+D;AACA,kD;AACA,6B;AACA,gD;;AAEA,2D;AACA,gE;;AAEA,4B;;AAEA,6C;;AAEA,mC;AACA,wB;AACA,2B;AACA,K;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,oB;AACA,I;AACA,+C;AACA,kD;AACA,oE;AACA,0C;AACA,I;AACA,2B;AACA,kC;AACA,8B;AACA,8B;AACA,iB;AACA,K;;AAEA,wD;AACA,e;AACA,uB;AACA,kB;AACA,c;AACA,kB;;AAEA,oC;AACA,wC;AACA,M;;AAEA,mD;AACA,oC;AACA,4C;AACA,8E;AACA,wB;AACA,M;;AAEA,sD;;AAEA,oD;AACA,6D;AACA,yD;AACA,mC;AACA,wB;AACA,K;;AAEA,wD;AACA,6B;AACA,wD;AACA,yE;AACA,yD;AACA,wB;AACA,K;;AAEA,0E;AACA,oD;;AAEA,oB;AACA,mE;;AAEA,4B;AACA,2D;AACA,0B;AACA,O;AACA,K;;AAEA,2D;AACA,iD;AACA,I;;AAEA,K;AACA,4E;AACA,8E;AACA,Y;AACA,I;AACA,wC;AACA,kC;AACA,iB;AACA,K;;AAEA,iD;AACA,mB;AACA,gC;;AAEA,uB;AACA,yB;AACA,uE;AACA,M;;AAEA,+E;AACA,iC;AACA,+B;;AAEA,8B;AACA,+B;AACA,Q;AACA,iC;;AAEA,kC;;AAEA,+E;AACA,sC;AACA,mC;AACA,I;AACA,yB;AACA,iC;;AAEA,8B;AACA,8B;AACA,Q;AACA,gC;;AAEA,kC;AACA,I;;AAEA,K;AACA,8E;AACA,yD;AACA,I;AACA,iD;AACA,iF;AACA,2B;AACA,gB;AACA,K;;AAEA,4B;AACA,wC;AACA,2B;AACA,U;AACA,0B;AACA,2B;AACA,K;AACA,I;;AAEA,K;AACA,yE;AACA,0E;AACA,uE;AACA,I;AACA,kC;AACA,8B;AACA,gB;AACA,K;;AAEA,sC;AACA,6C;AACA,I;;AAEA,K;AACA,0E;AACA,0E;AACA,6C;AACA,I;AACA,yB;AACA,8B;AACA,gB;AACA,K;;AAEA,yC;AACA,mD;AACA,I;;AAEA,K;AACA,6E;AACA,gF;AACA,4B;AACA,I;AACA,yB;AACA,8B;AACA,gB;AACA,K;;AAEA,6C;AACA,wD;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC5ZA,qC;AACA,2C;AACA,2C;AACA,6C;AACA,qC;AACA,I;;AAEA,sB;AACA,wB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACVA,qC;AACA,kC;;AAEA,kB;;AAEA,mB;AACA,Y;;AAEA,sD;AACA,6C;AACA,Q;AACA,2C;AACA,C;;AAEA,+C;AACA,4B;AACA,oB;AACA,8D;AACA,gC;AACA,8B;AACA,6C;AACA,uB;AACA,S;AACA,O;AACA,I;;AAEA,kD;AACA,4C;;AAEA,S;AACA,8C;AACA,e;AACA,qB;AACA,K;AACA,I;;AAEA,sB;AACA,mB;AACA,2B;AACA,gC;AACA,yC;AACA,I;;AAEA,wC;AACA,oB;AACA,uB;AACA,8B;AACA,qB;AACA,sB;AACA,kB;AACA,S;AACA,a;AACA,I;;AAEA,qB;AACA,I;;AAEA,yC;AACA,mB;AACA,I;;AAEA,6C;AACA,mB;AACA,G;AACA,G;;AAEA,0B","sourcesContent":["/*\nThe MIT License (MIT)\n\nCopyright (c) 2013 Chris Mather <mather@eventedmind.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n","/**\n * Utility methods available privately to the package.\n */\n\nRouterUtils = {};\n\n/**\n * Returns global on node or window in the browser.\n */\n\nRouterUtils.global = function () {\n  if (typeof window !== 'undefined')\n    return window;\n  else if (typeof global !== 'undefined')\n    return global;\n  else\n    return null;\n};\n\n/**\n * Given the name of a property, resolves to the value. Works with namespacing\n * too. If first parameter is already a value that isn't a string it's returned\n * immediately.\n *\n * Examples:\n *  'SomeClass' => window.SomeClass || global.someClass\n *  'App.namespace.SomeClass' => window.App.namespace.SomeClass\n *\n * @param {String|Object} nameOrValue\n */\n\nRouterUtils.resolveValue = function (nameOrValue) {\n  var global = RouterUtils.global()\n    , parts\n    , ptr;\n\n  if (_.isString(nameOrValue)) {\n    parts = nameOrValue.split('.')\n    ptr = global;\n    for (var i = 0; i < parts.length; i++) {\n      ptr = ptr[parts[i]];\n      if (!ptr)\n        throw new Error(parts.slice(0, i+1).join('.') + ' is ' + typeof ptr);\n    }\n  } else {\n    ptr = nameOrValue;\n  }\n\n  // final position of ptr should be the resolved value\n  return ptr;\n};\n\nRouterUtils.hasOwnProperty = function (obj, key) {\n  var prop = {}.hasOwnProperty;\n  return prop.call(obj, key);\n};\n\n/**\n * Don't mess with this function. It's exactly the same as the compiled\n * coffeescript mechanism. If you change it we can't guarantee that our code\n * will work when used with Coffeescript. One exception is putting in a runtime\n * check that both child and parent are of type Function.\n */\n\nRouterUtils.inherits = function (child, parent) {\n  if (RouterUtils.typeOf(child) !== '[object Function]')\n    throw new Error('First parameter to RouterUtils.inherits must be a function');\n   \n  if (RouterUtils.typeOf(parent) !== '[object Function]')\n    throw new Error('Second parameter to RouterUtils.inherits must be a function');\n\n  for (var key in parent) {\n    if (RouterUtils.hasOwnProperty(parent, key))\n      child[key] = parent[key];\n  }\n\n  function ctor () {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  child.__super__ = parent.prototype;\n  return child;\n};\n\nRouterUtils.toArray = function (obj) {\n  if (!obj)\n    return [];\n  else if (RouterUtils.typeOf(obj) !== '[object Array]')\n    return [obj];\n  else\n    return obj;\n};\n\nRouterUtils.typeOf = function (obj) {\n  if (obj && obj.typeName)\n    return obj.typeName;\n  else\n    return Object.prototype.toString.call(obj);\n};\n\nRouterUtils.extend = function (Super, definition) {\n  if (arguments.length === 1)\n    definition = Super;\n  else {\n    definition = definition || {};\n    definition.extend = Super;\n  }\n\n  return RouterUtils.create(definition, {delayInheritance: false});\n};\n\nRouterUtils.create = function (definition, options) {\n  var Constructor\n    , extendFrom\n    , savedPrototype;\n\n  options = options || {};\n  definition = definition || {};\n\n  if (RouterUtils.hasOwnProperty(definition, 'constructor'))\n    Constructor = definition.constructor;\n  else {\n    Constructor = function () {\n      if (Constructor.__super__ && Constructor.__super__.constructor)\n        return Constructor.__super__.constructor.apply(this, arguments);\n    }\n  }\n\n  extendFrom = definition.extend;\n\n  if (definition.extend) delete definition.extend;\n\n  var inherit = function (Child, Super, prototype) {\n    RouterUtils.inherits(Child, RouterUtils.resolveValue(Super));\n    if (prototype) _.extend(Child.prototype, prototype);\n  };\n\n  if (extendFrom) {\n    inherit(Constructor, extendFrom);\n  }\n\n  _.extend(Constructor.prototype, definition);\n\n  return Constructor;\n};\n\n/**\n * Assert that the given condition is truthy.\n *\n * @param {Boolean} condition The boolean condition to test for truthiness.\n * @param {String} msg The error message to show if the condition is falsy.\n */\n\nRouterUtils.assert = function (condition, msg) {\n  if (!condition)\n    throw new Error(msg);\n};\n\nRouterUtils.capitalize = function (str) {\n  return str[0].toUpperCase() + str.slice(1, str.length);\n};\n\nRouterUtils.classify = function (str) {\n  var re = /_|-|\\./;\n  return _.map(str.split(re), function (word) {\n    return RouterUtils.capitalize(word);\n  }).join('');\n};\n\n/**\n * Finds the given template in the Template namespace or returns the defaultFn\n * if no template is found in Template. If no defaultFn is provided and the\n * template is not found, throws an exception. In other words, ensures a\n * template function is returned.\n *\n * @param {String|Function} name The name of the template or the template\n * function itself.\n * @param {Function} [defaultFn] The default function to use if no template\n * function is found in the Template namespace.\n * @returns {Function}\n * @api private\n */\n\nRouterUtils.getTemplateFunction = function (name, defaultFn) {\n  var template = null;\n\n  if (_.isFunction(name))\n    template = name;\n  else if (_.isString(name))\n    template = Template[name];\n\n  if (!template && defaultFn)\n    template = defaultFn;\n\n  RouterUtils.assert(template, 'Template \"' + name + '\" not found');\n  return template;\n}\n","/**\n * Credit:\n *\n * The inspiration and some code for RoutePath comes from the page-js project:\n * https://github.com/visionmedia/page.js (MIT License), particularly the\n * compile method. RoutePath has been enhanced with a few features like the\n * ability to access the regular expression, and a few additional methods for\n * bidirectionally compiling and retrieving a path given some parameters.\n *\n */\n\n/**\n * Compiles a path with support for required, optional, wildcard and named\n * wildcard parameters. Also supports regular expression paths.\n *\n * Examples:\n *  \"/posts\"\n *  \"/posts/:_id\"\n *  \"/posts/:paramOne/:paramTwo\"\n *  \"/posts/:required/:optional?\"\n *  \"/posts/*\"\n *  \"/posts/:file(*)\"\n *  /^\\/commits\\/(\\d+)\\.\\.(\\d+)/\n *\n *  @constructor RoutePath\n *  @param {String|RegExp} path\n *  @param {Object} [options]\n *  @param {Boolean} [options.sensitive] Paths are case sensitive\n *  @param {Boolean} [options.strict] Truncate /? from path\n *  @api private\n */\n\nRoutePath = function (path, options) {\n  RouterUtils.assert(arguments.length >= 1,\n         'RoutePath constructor requires a path as the first parameter');\n\n  this.keys = [];\n  this.path = path || '';\n  this.options = options || {};\n};\n\nRoutePath.prototype = {\n  typeName: 'RoutePath',\n\n  constructor: RoutePath,\n\n  /**\n   * Compile the path. Typically you compile the path immediately after it is\n   * initialized, but this is not required. \n   *\n   *  @return {RoutePath}\n   *  @api public\n   */\n\n  compile: function () {\n    var self = this\n      , path\n      , options = self.options;\n\n    if (self.path instanceof RegExp) {\n      self.re = self.path;\n    } else {\n      path = self.path\n        .concat(options.strict ? '' : '/?')\n        .replace(/\\/\\(/g, '(?:/')\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional){\n            self.keys.push({ name: key, optional: !! optional });\n            slash = slash || '';\n            return ''\n              + (optional ? '' : slash)\n              + '(?:'\n              + (optional ? slash : '')\n              + (format || '') \n              + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n              + (optional || '');\n          }\n        )\n        .replace(/([\\/.])/g, '\\\\$1')\n        .replace(/\\*/g, '(.*)');\n      \n      self.re = new RegExp('^' + path + '$', options.sensitive ? '' : 'i');\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns an array of parameters given a path. The array may have named\n   * properties in addition to indexed values.\n   *\n   * @param {String} path\n   * @return {Array}\n   * @api public\n   */\n\n  params: function (path) {\n    if (!path) return null;\n\n    var params = []\n      , m = this.exec(path)\n      , queryString\n      , keys = this.keys\n      , key\n      , value;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      key = keys[i - 1];\n      value = typeof m[i] == 'string' ? decodeURIComponent(m[i]) : m[i];\n      if (key) {\n        params[key.name] = params[key.name] !== undefined ? \n          params[key.name] : value;\n      } else\n        params.push(value);\n    }\n\n    queryString = decodeURI(path).split('?')[1];\n\n    if (queryString) {\n      _.each(queryString.split('&'), function (paramString) {\n        paramParts = paramString.split('=');\n        params[paramParts[0]] = decodeURIComponent(paramParts[1]);\n      });\n    }\n\n    return params;\n  },\n\n  /**\n   * Returns true if the path matches and false otherwise.\n   *\n   * @param {String} path\n   * @return {Boolean} \n   * @api public\n   */\n  test: function (path) {\n    var qsIndex = path.indexOf('?')\n      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n    \n    return this.re.test(pathname);\n  },\n\n  /**\n   * Calls the exec method of the compiled path regular expression and returns\n   * the result.\n   *\n   * @param {String} path\n   * @return {Array|null}\n   * @api public\n   */\n  exec: function (path) {\n    var qsIndex = path.indexOf('?')\n      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n    return this.re.exec(pathname);\n  },\n\n  /**\n   * Given an object or array of params, returns a path. This is used to create\n   * Handlebars pathFor and urlFor helpers for example. If the params object has\n   * a 'query' property, its values are used as query params.\n   *\n   * @param {Object|Array} params\n   * @param {String|Object} [params.query] Query parameters to be appended to\n   * the path.\n   * @return {String}\n   * @api public\n   */\n  resolve: function (params) {\n    var value\n      , isValueDefined\n      , result\n      , wildCardCount = 0\n      , path = this.path\n      , query;\n\n    params = params || [];\n    query = params.query;\n\n    if (path instanceof RegExp) {\n      throw new Error('Cannot currently resolve a regular expression path');\n    } else {\n      path = this.path\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional) {\n            slash = slash || '';\n            value = params[key];\n            isValueDefined = typeof value !== 'undefined';\n\n            if (optional && !isValueDefined) {\n              slash = '';\n              value = '';\n            } else if (!isValueDefined) {\n              throw new Error(key + ' not found in params');\n            }\n\n            value = _.isFunction(value) ? value.call(params) : value;\n            return slash + encodeURIComponent(value);\n          }\n        )\n        .replace(\n          /\\*/g,\n          function (match) {\n            if (typeof params[wildCardCount] === 'undefined') {\n              throw new Error(\n                'You are trying to access a wild card parameter at index ' + \n                wildCardCount +\n                ' but the value of params at that index is undefined');\n            }\n\n            return encodeURIComponent(params[wildCardCount++]);\n          }\n        );\n\n      if (query) {\n        if (_.isObject(query)) {\n          query = _.map(_.pairs(query), function (queryPart) {\n            return queryPart[0] + '=' + encodeURIComponent(queryPart[1]);\n          }).join('&');\n        }\n\n        path = path + '?' + query;\n      }\n    }\n    \n    return path;\n  }\n};\n","/**\n * A simple object that gets created by the router and passed on to the route\n * handler. It has a reactive result method that can be used by the route\n * handler to trigger an invlidation somewhere. This is how the Router renders\n * routes to the page for example.\n *\n * @constructor RouteContext\n * @param {String} path\n * @param {IronRouter} router\n * @param {Route} route\n * @param {Object} [options]\n * @api private\n */\n\nRouteContext = function (path, router, route, options) {\n  RouterUtils.assert(typeof path === 'string', 'RouteContext requires path parameter');\n  RouterUtils.assert(router instanceof IronRouter, 'RouteContext requires router parameter');\n  RouterUtils.assert(route, 'RouteContext requires route parameter');\n\n  options = this.options = options || {}\n  this._deps = new Deps.Dependency;\n  this._result = null;\n  this.path = path;\n  this.router = router;\n  this.route = route;\n  this.state = options.state;\n  this.params = route.params(path);\n  this.action = route.action || 'run';\n  this.controller = route.controller;\n  this.isReactive = route.isReactive;\n};\n\nRouteContext.prototype = {\n  typeName: 'RouteContext',\n\n  constructor: RouteContext,\n\n  /**\n   * Returns an object that can be used to store state (e.g. pushState on the\n   * client). The object includes this.state and this.path\n   *\n   * @returns {Object}\n   * @api public\n   */\n\n  getState: function () {\n    return _.extend({}, this.state, {\n      path: this.path\n    });\n  }\n};\n","/**\n * Container class for route information.\n *\n * Example: \n *  new Route(router, 'postShow', {path: '/posts/:_id'});\n *  new Route(router, 'postShow', {path: '/posts/:_id'}, function () {});\n *  new Route(router, 'postShow', {path: '/posts/:_id', handler: function () {}});\n *\n * @constructor Route\n * @exports Route\n * @param {IronRouter} router\n * @param {String} name The name will be used as the default path if none is\n * specified in the options. For example, 'test' will become '/test'\n * @param {Object} [options]\n * @param {String} [options.path]\n * @param {Function} [options.handler]\n * @param {Function} [handler] Handler function can be passed as the last\n * parameter or as an option. A handler function is not required but will be\n * used by the Router if one is provided.\n * @api public\n */\n\nRoute = function (router, name, options, handler) {\n  var path;\n\n  RouterUtils.assert(router instanceof IronRouter);\n\n  RouterUtils.assert(_.isString(name),\n    'Route constructor requires a name as the second parameter');\n\n  if (_.isFunction(options))\n    options = { handler: options };\n\n  if (_.isFunction(handler))\n    options.handler = handler;\n\n  options = this.options = options || {};\n  path = options.path || ('/' + name);\n\n  this.router = router;\n  this.originalPath = path;\n  this.compiledPath = new RoutePath(path, options).compile();\n  this.name = name;\n  this.where = options.where || 'client';\n  this.handler = this.handler || options.handler;\n  this.action = options.action;\n  this.controller = options.controller;\n\n  if (typeof options.reactive !== 'undefined')\n    this.isReactive = options.reactive;\n  else\n    this.isReactive = true;\n};\n\nRoute.prototype = {\n  typeName: 'Route',\n\n  constructor: Route,\n\n  /**\n   * Returns true if the given path matches this route's compiled path. Proxies\n   * to the RoutePath instance stored in compiledPath.\n   *\n   * @param {String} path\n   * @return {Boolean}\n   * @api public\n   */\n\n  test: function (path) {\n    return this.compiledPath.test(path);\n  },\n\n  /**\n   * Returns an array or object of params given a path. Proxies to the RoutePath\n   * instance stored in compiledPath.\n   *\n   * @param {String} path\n   * @return {Array|Object}\n   * @api public\n   */\n\n  params: function (path) {\n    return this.compiledPath.params(path);\n  },\n\n  /**\n   * Returns a path given a params object or array. Proxies to the RoutePath\n   * instance stored in compiledPath.\n   *\n   * Example:\n   *  route = new Route(router, 'postShow', {path: '/posts/:id'});\n   *  route.path({id: 5}) => '/posts/5'\n   *\n   * @param {Array|Object} params\n   * @return {String}\n   * @api public\n   */\n\n  path: function (params) {\n    return this.compiledPath.resolve(params);\n  },\n\n  /**\n   * Returns an absolute url given a params object or array. Uses\n   * Meteor.absoluteUrl() for the root url.\n   *\n   * Example:\n   *  route = new Route(router, 'postShow', {path: '/posts/:id'});\n   *  route.url({id: 5}) => 'http://www.eventedmind.com/posts/5'\n   *\n   * @param {Array|Object} params\n   * @return {String}\n   * @api public\n   */\n\n  url: function (params) {\n    var path = this.path(params);\n    if (path[0] === '/')\n      path = path.slice(1, path.length);\n    return Meteor.absoluteUrl() + path;\n  }\n};\n","/**\n * Main class for handling data and rendering logic for a route.\n *\n * @constructor RouteController\n * @exports RouteController\n * @param {RouteContext} context\n * @param {Object} [options]\n * @param {String|Function} [options.template]\n * @param {String|Function} [options.loadingTemplate]\n * @param {String|Function} [options.notFoundTemplate]\n * @param {Object|Function} [options.data]\n */\n\nRouteController = function (context, options) {\n  var routerOptions\n    , routeOptions\n    , self = this;\n\n  RouterUtils.assert(context, 'RouteController requires a RouteContext');\n\n  options = this.options = options || {};\n\n  routerOptions = (context.router && context.router.options) || {};\n  routeOptions = (context.route && context.route.options) || {};\n\n  this.params = context.params || [];\n  this.route = context.route;\n  this.router = context.router;\n  this.context = context;\n\n  var getOption = function(name) {\n    return options[name]\n      || routeOptions[name]\n      || routerOptions[name] \n      || self[name];\n  };\n\n  this['onBeforeRun'] = getOption('onBeforeRun');\n  this['onAfterRun'] = getOption('onAfterRun');\n  this['onBeforeRerun'] = getOption('onBeforeRerun');\n  this['onAfterRerun'] = getOption('onAfterRerun');\n\n  this.stopped = false;\n  this.isFirstRun = true;\n\n  this.before = []\n    .concat(RouterUtils.toArray(routerOptions.before))\n    .concat(RouterUtils.toArray(routeOptions.before))\n    .concat(RouterUtils.toArray(options.before))\n    .concat(RouterUtils.toArray(this.before));\n\n  this.after = []\n    .concat(RouterUtils.toArray(routerOptions.after))\n    .concat(RouterUtils.toArray(routeOptions.after))\n    .concat(RouterUtils.toArray(options.after))\n    .concat(RouterUtils.toArray(this.after));\n\n  this.initialize(context, options);\n};\n\nRouteController.prototype = {\n  typeName: 'RouteController',\n\n  constructor: RouteController,\n\n  initialize: function (context, options) {\n    throw new Error('not implemented');\n  },\n\n  before: [],\n\n  /**\n   * After hooks to run after the controller action is called. The Router will\n   * typically call the runHooks method to call this function. This property is\n   * defined for inheritance. Each instance gets its own copy of after hooks at\n   * constructor time. This means that after hooks added to the prototype after\n   * constructor time will not be used in the instance.\n   */\n\n  after: [],\n\n  /**\n   * Run the hooks for the given name (e.g. before/after)\n   *\n   * @param {String} name The name of the hooks to run (e.g. before/after)\n   * @api public\n   */\n\n  runHooks: function (name) {\n    var self = this\n      , hooks = self[name];\n\n    if (!hooks) return;\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (this.stopped) break;\n      hooks[i].call(this);\n    }\n  },\n\n\n  /**\n   * The default action for the controller. Called by the Router. Calls the main\n   * render method and then the render method for each template specified in\n   * renderTemplates.\n   *\n   * @api public\n   */\n\n  run: function () {\n    throw new Error('not implemented');\n  },\n\n  /**\n   * Stop running this controller and redirect to a new path. Same parameters as\n   * those of Router.go.\n   *\n   * @api public\n   */\n\n  redirect: function (/* args */) {\n    this.stop();\n    return this.router.go.apply(this.router, arguments);\n  },\n  \n  /**\n   * Set the stopped property on the controller to true. This would typically be\n   * used in a before filter or hook. If the controller is marked as stopped, it\n   * tells the router not to call the controller's action or afterRun callbacks\n   * and hooks. This property is not used internally by the controller.\n   *\n   * @api public\n   */\n  stop: function() {\n    this.stopped = true;\n  },\n\n  /**\n   * Hook called on the before the first run - either the run method being\n   * called or another action being called. This method is called from the\n   * router. It should only be called once. Not on reactive reruns.\n   *\n   * @api public\n   */\n\n  onBeforeRun: function () {\n  },\n\n  /**\n   * Hook called after the first run - either the run method being\n   * called or another action being called. This method is called from the\n   * router. It should only be called once. Not on reactive reruns.\n   *\n   * @api public\n   */\n\n  onAfterRun: function () {\n  },\n\n  /**\n   * Hook called before a reactive rerun. Called by the router.\n   *\n   * @api public\n   */\n\n  onBeforeRerun: function () {\n  },\n\n  /**\n   * Hook called after a reactive rerun. Called by the router.\n   *\n   * @api public\n   */\n\n  onAfterRerun: function () {\n  }\n};\n\n_.extend(RouteController, {\n  /**\n   * Inherit from RouteController\n   *\n   * @param {Object} definition Prototype properties for inherited class.\n   */\n\n  extend: function (definition) {\n    return RouterUtils.extend(this, definition);\n  }\n});\n","/**\n * The main Router class which runs on both client and server.\n *\n * @constructor IronRouter\n * @exports IronRouter\n * @param {Object} [options]\n * @api public\n */\n\nIronRouter = function (options) {\n  this.configure(options);\n\n  /**\n   * The routes array which doubles as a named route index by adding\n   * properties to the array.\n   *\n   * @api public\n   */\n  this.routes = [];\n\n  /**\n   * The current context. This is set anytime a new route is dispatched. It's\n   * a reactive variable which you can get by calling Router.current();\n   *\n   * @api private\n   */\n  this._current = null;\n\n  /**\n   * Dependency to track dependencies on this._current\n   *\n   * @api private\n   */\n  this._deps = new Deps.Dependency;\n};\n\n\nIronRouter.prototype = {\n  typeName: 'IronRouter',\n\n  constructor: IronRouter,\n\n  /**\n   * Configure instance with options. This can be called at any time. If the\n   * instance options object hasn't been created yet it is created here.\n   *\n   * @param {Object} options\n   * @return {IronRouter}\n   * @api public\n   */\n\n  configure: function (options) {\n    this.options = this.options || {};\n    _.extend(this.options, options);\n    return this;\n  },\n\n  /**\n   * Convenience function to define a bunch of routes at once. In the future we\n   * might call the callback with a custom dsl.\n   *\n   * Example:\n   *  Router.map(function () {\n   *    this.route('posts');\n   *  });\n   *\n   *  @param {Function} cb\n   *  @return {IronRouter}\n   *  @api public\n   */\n\n  map: function (cb) {\n    RouterUtils.assert(_.isFunction(cb),\n           'map requires a function as the first parameter');\n    cb.call(this);\n    return this;\n  },\n\n  /**\n   * Define a new route. You must name the route, but as a second parameter you\n   * can either provide an object of options or a Route instance.\n   *\n   * @param {String} name The name of the route\n   * @param {Object} [options] Options to pass along to the route\n   * @param {Function} [handler] A handler function for the route. This usually\n   * isn't required as a handler is automatically created for you if one doesn't\n   * exist. Behavior is different on client and server.\n   * @return {Route}\n   * @api public\n   */\n\n  route: function (name, options, handler) {\n    var route;\n\n    RouterUtils.assert(_.isString(name), 'name is a required parameter');\n    \n    if (options instanceof Route)\n      route = options;\n    else\n      route = new Route(this, name, options, handler);\n\n    this.routes[name] = route;\n    this.routes.push(route);\n    return route;\n  },\n\n  /**\n   * Returns a path for a given routeName and params object. Used in Handlebars\n   * path helper for example.\n   *\n   * Example:\n   *  Router.route('postShow', {path: '/posts/:id'});\n   *  Router.path('postShow', {id: 5, query: {q: 'search'}) =>\n   *  '/posts/5?q=search'\n   * \n   * @param {String} routeName The name of the route to use.\n   * @param {Array|Object} params\n   * @return {String}\n   * @api public\n   */\n\n  //XXX fix up error handling here.\n  path: function (routeName, params) {\n    RouterUtils.assert(this.routes[routeName],\n     'You called Router.path for a route named ' + routeName + ' but that that route doesn\\'t seem to exist. Are you sure you created it?');\n    return this.routes[routeName].path(params);\n  },\n\n  /**\n   * Returns a full url for a given routeName and params object. Used in\n   * Handlebars url helper for example.\n   *\n   * Example:\n   *  Router.route('postShow', {path: '/posts/:id'});\n   *  Router.url('postShow', {id: 5, query: {q: 'search'}) =>\n   *  'http://www.eventedmind.com/posts/5?q=search'\n   */\n\n  url: function (routeName, params) {\n    RouterUtils.assert(this.routes[routeName], 'url: No route found named ' + routeName);\n    return this.routes[routeName].url(params);\n  },\n\n  /**\n   * Finds a route for the given path and runs it if found. If the route is\n   * found but is for a different environment (client vs. server) the\n   * onUnhandled function is called. If the route is not found at all (on client\n   * or server) the onRouteNotFound method is called. These functions are\n   * overridden on the client and server IronRouters.\n   *\n   * @param {String} path The path to dispatch\n   * @param {Object} [options] Options to pass along to the onRun method\n   * @param {Function} [cb] Optional callback to call if the path was \n   * successfully dispatched. Note that if a redirect occurs the original \n   * callback will not be called.\n   * @param {Function} [onUnhandled] Optional override for onUnhandled function.\n   * For example, the client router overrides this to unhook client event\n   * handlers and make a request to the server.\n   * @return {IronRouter}\n   * @api public\n   */\n\n  dispatch: function (path, options, cb, onUnhandled) {\n    var self = this\n      , routes = self.routes\n      , route\n      , where = Meteor.isClient ? 'client' : 'server'\n      , i = 0;\n\n    function next () {\n      route = routes[i++];\n      onUnhandled = onUnhandled || self.onUnhandled;\n\n      if (!route) {\n        return self.onRouteNotFound(path, options);\n      }\n\n      if (route.test(path)) {\n        if (route.where !== where) \n          return onUnhandled(path, options);\n        self.run(path, route, options, cb, onUnhandled);\n      } else next();\n    }\n\n    next();\n    return this;\n  },\n\n  /**\n   * Creates a new RouteContext and runs the given route for the given path by\n   * calling the onRun method of the router. After onRun completes, if the\n   * context hasn't changed in the mean time (i.e. the route handler calls run\n   * again before this function has completed), the deps.changed() method is called\n   * causing callers that are dependent on Router.current() to be rerun. This\n   * method also double checks that the given route is supposed to be run in the\n   * current environment (client or server). If not, the onUnhandled function of\n   * router is called. Typically, this method shouldn't be called directly. You\n   * should be calling the dispatch method instead.\n   *\n   * @param {String} path\n   * @param {Route} route\n   * @param {Object} [options]\n   * @param {Function} [cb] Optional callback to call if the path was \n   * successfully dispatched. Note that if a redirect occurs the original \n   * callback will not be called.\n   * @param {Function} [onUnhandled] Optional override for onUnhandled function.\n   * For example, the client router overrides this to unhook client event\n   * handlers and make a request to the server.\n   * @return {IronRouter}\n   * @api public\n   */\n\n  run: function (path, route, options, cb, onUnhandled) {\n    var self = this\n      , context\n      , controller\n      , where = Meteor.isClient ? 'client' : 'server';\n\n    RouterUtils.assert(path, 'You must run with a path');\n    RouterUtils.assert(route, 'You must provide a route to the run method');\n\n    // one last check to see if we should handle the route here\n    onUnhandled = onUnhandled || self.onUnhandled;\n    if (route.where != where)\n      onUnhandled && onUnhandled(path, options);\n\n    context = new RouteContext(path, this, route, options);\n    controller = this.getControllerForContext(context, options);\n\n    this._current = context;\n\n    this.onRun(controller, context, options);\n\n    if (context == this._current) {\n      cb && cb(context);\n      this._deps.changed();\n    }\n    return this;\n  },\n\n  /**\n   * Get a controller instance for the given action, context and options. There\n   * are four cases:\n   *\n   *  1) handler is defined directly on a route\n   *  2) controller option is defined on the route\n   *  3) intelligently find the controller class in global namespace\n   *  4) create a new anonymous controller\n   *\n   * @param {String} action\n   * @param {RouteContext} context\n   * @param {Object} [options]\n   * @return {RouteController}\n   * @api private\n   */\n\n  getControllerForContext: function (context, options) {\n    var handler\n      , controllerClass\n      , controller\n      , action\n      , routeName;\n\n    var classify = function (name) {\n      return RouterUtils.classify(name);\n    };\n\n    var getControllerFromWindow = function (name) {\n      var controller = window[name];\n      if (typeof controller === 'undefined')\n        throw new Error('controller \"' + name + '\" is not defined on window');\n      return controller;\n    };\n\n    action = context.action = context.action || 'run';\n\n    // case 1: handler defined directly on the route\n    if (handler = (context.route && context.route.handler)) {\n      controller = new RouteController(context, options);\n      controller[action] = handler;\n      return controller;\n    }\n\n    // case 2: controller option is defined on the route\n    if (context.controller) {\n      controllerClass = _.isString(context.controller) ?\n        getControllerFromWindow(context.controller) : context.controller;\n      controller = new controllerClass(context, options);\n      return controller;\n    }\n\n    // case 3: intelligently find the controller class in global namespace\n    routeName = context.route && context.route.name;\n\n    if (routeName) {\n      controllerClass = window[classify(routeName + 'Controller')];\n\n      if (controllerClass) {\n        controller = new controllerClass(context, options);\n        return controller;\n      }\n    }\n\n    // case 4: nothing found so create a default controller\n    return new RouteController(context, options);\n  },\n\n  /**\n   * Run a controller with a given context. Calls the before and after hooks\n   * and attaches to the onRender callback to render results into the router's\n   * layout.\n   *\n   * @param {RouteController} controller\n   * @param {RouteContext} context\n   * @api private\n   */\n\n  runController: function (controller, context) {\n    var self = this\n      , action = context.action;\n\n    RouterUtils.assert(\n      controller[action],\n      'No action \"' + action + '\" on controller ' + controller.typeName\n    );\n\n    // Since runController can be reactive, this resets the controller to a non\n    // stopped state on each run.\n    controller.stopped = false;\n\n    if (controller.isFirstRun)\n      controller.onBeforeRun();\n    else\n      controller.onBeforeRerun();\n\n    controller.runHooks('before');\n\n    // if the user stopped the controller in a before filter or hook then don't\n    // run the rest of the controller.\n    if (controller.stopped) return;\n    \n    controller[action]();\n    controller.runHooks('after');\n\n    if (controller.isFirstRun)\n      controller.onAfterRun();\n    else\n      controller.onAfterRerun();\n\n    controller.isFirstRun = false;\n  },\n\n  /**\n   * Reactive accessor for the current context. You can also get a nonreactive\n   * value by specifiying {reactive: false} as an option.\n   *\n   * @param {Object} [opts] configuration options\n   * @param {Boolean} [opts.reactive] Set to false to enable a non-reactive read.\n   * @return {RouteContext}\n   * @api public\n   */\n\n  current: function (opts) {\n    if (opts && opts.reactive === false)\n      return this._current;\n    else {\n      this._deps.depend();\n      return this._current;\n    }\n  },\n\n  /**\n   * Called by the run method to run a context which by this point should\n   * include the path and route. Should be overridden in client and server\n   * routers since the behavior will be different on client vs. server.\n   *\n   * @param {RouteContext} context\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onRun: function (context, options) {\n    throw new Error('onRun not implemented');\n  },\n\n  /**\n   * Called from the dispatch or run method when a route was found but not\n   * handled in the current environment (e.g. client or server). Should be\n   * overridden in client and server routers.\n   *\n   * @param {String} path\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onUnhandled: function (path, options) {\n    throw new Error('onUnhandled not implemented');\n  },\n\n  /**\n   * Called from the dispatch method when a route was not found for the given\n   * dispatched path. This method can be overridden in client and server routers\n   * but doesn't have to be.\n   *\n   * @param {String} path\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onRouteNotFound: function (path, options) {\n    throw new Error('No route found for path: ' + path);\n  }\n};\n","_.extend(RouteController.prototype, {\n  initialize: function (context, options) {\n    this.request = context.options.request;\n    this.response = context.options.response;\n    this.next = context.options.next;\n  },\n\n  onRun: function () {\n    this.response.end();\n  }\n});\n","var connect = Npm.require('connect');\nvar Fiber = Npm.require('fibers');\n\nvar root = global;\n\nvar connectHandlers\n  , connect;\n\nif (typeof __meteor_bootstrap__.app !== 'undefined') {\n  connectHandlers = __meteor_bootstrap__.app;\n} else {\n  connectHandlers = WebApp.connectHandlers;\n}\n\nServerRouter = RouterUtils.extend(IronRouter, {\n  constructor: function () {\n    var self = this;\n    ServerRouter.__super__.constructor.apply(this, arguments);\n    Meteor.startup(function () {\n      setTimeout(function () {\n        if (self.options.autoStart !== false)\n          self.start();\n      });\n    });\n  },\n\n  onRun: function (controller, context, options) {\n    var response = context.options.response;\n\n    try {\n      this.runController(controller, context);\n    } finally {\n      response.end();\n    }\n  },\n\n  start: function () {\n    connectHandlers\n      .use(connect.query())\n      .use(connect.bodyParser())\n      .use(_.bind(this.onRequest, this));\n  },\n\n  onRequest: function (req, res, next) {\n    var self = this;\n    Fiber(function () {\n      self.dispatch(req.url, {\n        request: req,\n        response: res,\n        next: next\n      });\n    }).run();\n  },\n\n  stop: function () {\n  },\n\n  onUnhandled: function (path, options) {\n    options.next();\n  },\n\n  onRouteNotFound: function (path, options) {\n    options.next();\n  }\n});\n\nRouter = new ServerRouter;\n"]}