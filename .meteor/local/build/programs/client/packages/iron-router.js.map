)]}'
{"version":3,"file":"/packages/iron-router.js","sources":["iron-router/license.js","iron-router/lib/router_utils.js","iron-router/lib/route_path.js","iron-router/lib/route_context.js","iron-router/lib/route.js","iron-router/lib/route_controller.js","iron-router/lib/router.js","iron-router/lib/client/location.js","iron-router/lib/client/yield_partials_dict.js","iron-router/lib/client/client_router.js","iron-router/lib/client/default_layout.html","iron-router/lib/client/route_controller.js","iron-router/lib/client/helpers.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,qB;;AAEA,wD;;AAEA,4E;AACA,6E;AACA,4E;AACA,yE;AACA,qE;AACA,wD;;AAEA,0E;AACA,mD;;AAEA,0E;AACA,wE;AACA,2E;AACA,sE;AACA,6E;AACA,yE;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;ACtBA,G;AACA,sD;AACA,G;;AAEA,iB;;AAEA,G;AACA,mD;AACA,G;;AAEA,kC;AACA,oC;AACA,kB;AACA,yC;AACA,kB;AACA,M;AACA,gB;AACA,E;;AAEA,G;AACA,8E;AACA,+E;AACA,e;AACA,E;AACA,Y;AACA,uD;AACA,+D;AACA,E;AACA,qC;AACA,G;;AAEA,mD;AACA,mC;AACA,W;AACA,U;;AAEA,gC;AACA,kC;AACA,iB;AACA,4C;AACA,0B;AACA,e;AACA,6E;AACA,K;AACA,U;AACA,sB;AACA,G;;AAEA,uD;AACA,a;AACA,E;;AAEA,kD;AACA,+B;AACA,6B;AACA,E;;AAEA,G;AACA,uE;AACA,4E;AACA,+E;AACA,yD;AACA,G;;AAEA,iD;AACA,wD;AACA,kF;AACA,G;AACA,yD;AACA,mF;;AAEA,2B;AACA,gD;AACA,+B;AACA,G;;AAEA,oB;AACA,6B;AACA,G;;AAEA,oC;AACA,+B;AACA,qC;AACA,e;AACA,E;;AAEA,sC;AACA,W;AACA,c;AACA,wD;AACA,iB;AACA,M;AACA,e;AACA,E;;AAEA,qC;AACA,0B;AACA,wB;AACA,M;AACA,+C;AACA,E;;AAEA,mD;AACA,6B;AACA,uB;AACA,Q;AACA,kC;AACA,8B;AACA,G;;AAEA,mE;AACA,E;;AAEA,qD;AACA,iB;AACA,gB;AACA,qB;;AAEA,0B;AACA,gC;;AAEA,4D;AACA,yC;AACA,Q;AACA,+B;AACA,qE;AACA,wE;AACA,K;AACA,G;;AAEA,iC;;AAEA,kD;;AAEA,oD;AACA,iE;AACA,wD;AACA,I;;AAEA,mB;AACA,qC;AACA,G;;AAEA,8C;;AAEA,qB;AACA,E;;AAEA,G;AACA,6C;AACA,E;AACA,2E;AACA,2E;AACA,G;;AAEA,gD;AACA,iB;AACA,yB;AACA,E;;AAEA,yC;AACA,yD;AACA,E;;AAEA,uC;AACA,oB;AACA,+C;AACA,wC;AACA,c;AACA,E;;AAEA,G;AACA,8E;AACA,2E;AACA,wE;AACA,iC;AACA,E;AACA,yE;AACA,mB;AACA,2E;AACA,+C;AACA,sB;AACA,e;AACA,G;;AAEA,8D;AACA,sB;;AAEA,yB;AACA,oB;AACA,4B;AACA,8B;;AAEA,6B;AACA,yB;;AAEA,oE;AACA,kB;AACA,C;;;;;;;;;;;;;;;;;;;ACtMA,G;AACA,U;AACA,E;AACA,8E;AACA,yE;AACA,2E;AACA,6E;AACA,yE;AACA,E;AACA,G;;AAEA,G;AACA,0E;AACA,+D;AACA,E;AACA,Y;AACA,Y;AACA,iB;AACA,gC;AACA,iC;AACA,c;AACA,qB;AACA,gC;AACA,E;AACA,0B;AACA,+B;AACA,6B;AACA,iE;AACA,2D;AACA,gB;AACA,G;;AAEA,sC;AACA,2C;AACA,yE;;AAEA,iB;AACA,yB;AACA,+B;AACA,E;;AAEA,uB;AACA,wB;;AAEA,yB;;AAEA,K;AACA,6E;AACA,4C;AACA,I;AACA,yB;AACA,iB;AACA,K;;AAEA,wB;AACA,mB;AACA,Y;AACA,+B;;AAEA,sC;AACA,0B;AACA,Y;AACA,sB;AACA,2C;AACA,iC;AACA,iB;AACA,iD;AACA,kE;AACA,iE;AACA,gC;AACA,qB;AACA,uC;AACA,qB;AACA,uC;AACA,+B;AACA,wE;AACA,iC;AACA,W;AACA,S;AACA,oC;AACA,gC;AACA,M;AACA,2E;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,0E;AACA,8C;AACA,I;AACA,yB;AACA,oB;AACA,gB;AACA,K;;AAEA,2B;AACA,2B;;AAEA,mB;AACA,2B;AACA,mB;AACA,wB;AACA,W;AACA,c;;AAEA,mD;AACA,wB;AACA,wE;AACA,gB;AACA,4D;AACA,mC;AACA,Y;AACA,2B;AACA,K;;AAEA,gD;;AAEA,sB;AACA,6D;AACA,4C;AACA,kE;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,K;AACA,0D;AACA,I;AACA,yB;AACA,uB;AACA,gB;AACA,K;AACA,yB;AACA,mC;AACA,4D;AACA,I;AACA,kC;AACA,I;;AAEA,K;AACA,8E;AACA,gB;AACA,I;AACA,yB;AACA,yB;AACA,gB;AACA,K;AACA,yB;AACA,mC;AACA,4D;AACA,kC;AACA,I;;AAEA,K;AACA,+E;AACA,gF;AACA,6D;AACA,I;AACA,iC;AACA,6E;AACA,c;AACA,qB;AACA,gB;AACA,K;AACA,8B;AACA,a;AACA,sB;AACA,c;AACA,yB;AACA,wB;AACA,c;;AAEA,0B;AACA,yB;;AAEA,iC;AACA,4E;AACA,Y;AACA,sB;AACA,iB;AACA,iD;AACA,mE;AACA,gC;AACA,gC;AACA,0D;;AAEA,8C;AACA,yB;AACA,yB;AACA,yC;AACA,4D;AACA,a;;AAEA,qE;AACA,qD;AACA,W;AACA,S;AACA,iB;AACA,gB;AACA,4B;AACA,+D;AACA,8B;AACA,6E;AACA,+B;AACA,uE;AACA,a;;AAEA,+D;AACA,W;AACA,U;;AAEA,kB;AACA,gC;AACA,8D;AACA,yE;AACA,uB;AACA,S;;AAEA,kC;AACA,O;AACA,K;AACA,I;AACA,gB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACpOA,G;AACA,6E;AACA,yE;AACA,8E;AACA,kC;AACA,E;AACA,4B;AACA,uB;AACA,6B;AACA,uB;AACA,4B;AACA,e;AACA,G;;AAEA,wD;AACA,uF;AACA,6F;AACA,qE;;AAEA,wC;AACA,mC;AACA,sB;AACA,mB;AACA,uB;AACA,qB;AACA,6B;AACA,mC;AACA,sC;AACA,qC;AACA,qC;AACA,E;;AAEA,0B;AACA,2B;;AAEA,4B;;AAEA,K;AACA,6E;AACA,0D;AACA,I;AACA,sB;AACA,gB;AACA,K;;AAEA,yB;AACA,qC;AACA,qB;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AClDA,G;AACA,yC;AACA,E;AACA,Y;AACA,yD;AACA,yE;AACA,kF;AACA,E;AACA,qB;AACA,iB;AACA,6B;AACA,4E;AACA,oE;AACA,4B;AACA,iC;AACA,sC;AACA,yE;AACA,4E;AACA,yC;AACA,c;AACA,G;;AAEA,mD;AACA,W;;AAEA,mD;;AAEA,sC;AACA,iE;;AAEA,4B;AACA,mC;;AAEA,4B;AACA,8B;;AAEA,yC;AACA,sC;;AAEA,uB;AACA,2B;AACA,6D;AACA,mB;AACA,yC;AACA,iD;AACA,+B;AACA,uC;;AAEA,8C;AACA,uC;AACA,M;AACA,2B;AACA,E;;AAEA,mB;AACA,oB;;AAEA,qB;;AAEA,K;AACA,+E;AACA,sD;AACA,I;AACA,yB;AACA,sB;AACA,gB;AACA,K;;AAEA,yB;AACA,wC;AACA,I;;AAEA,K;AACA,gF;AACA,qC;AACA,I;AACA,yB;AACA,2B;AACA,gB;AACA,K;;AAEA,2B;AACA,0C;AACA,I;;AAEA,K;AACA,4E;AACA,qC;AACA,I;AACA,a;AACA,kE;AACA,uC;AACA,I;AACA,iC;AACA,qB;AACA,gB;AACA,K;;AAEA,2B;AACA,6C;AACA,I;;AAEA,K;AACA,iE;AACA,2C;AACA,I;AACA,a;AACA,kE;AACA,gE;AACA,I;AACA,iC;AACA,qB;AACA,gB;AACA,K;;AAEA,0B;AACA,iC;AACA,wB;AACA,wC;AACA,uC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACzHA,G;AACA,gE;AACA,E;AACA,+B;AACA,2B;AACA,gC;AACA,4B;AACA,8C;AACA,qD;AACA,sD;AACA,0C;AACA,G;;AAEA,+C;AACA,mB;AACA,kB;AACA,kB;;AAEA,yE;;AAEA,yC;;AAEA,mE;AACA,gE;;AAEA,qC;AACA,6B;AACA,+B;AACA,yB;;AAEA,kC;AACA,wB;AACA,2B;AACA,6B;AACA,oB;AACA,I;;AAEA,iD;AACA,+C;AACA,qD;AACA,mD;;AAEA,uB;AACA,yB;;AAEA,kB;AACA,sD;AACA,qD;AACA,gD;AACA,8C;;AAEA,iB;AACA,qD;AACA,oD;AACA,+C;AACA,6C;;AAEA,oC;AACA,E;;AAEA,6B;AACA,8B;;AAEA,+B;;AAEA,2C;AACA,uC;AACA,I;;AAEA,a;;AAEA,K;AACA,8E;AACA,+E;AACA,+E;AACA,+E;AACA,uD;AACA,K;;AAEA,Y;;AAEA,K;AACA,yD;AACA,I;AACA,0E;AACA,gB;AACA,K;;AAEA,6B;AACA,mB;AACA,2B;;AAEA,uB;;AAEA,4C;AACA,8B;AACA,0B;AACA,K;AACA,I;;;AAGA,K;AACA,gF;AACA,4E;AACA,qB;AACA,I;AACA,gB;AACA,K;;AAEA,oB;AACA,uC;AACA,I;;AAEA,K;AACA,gF;AACA,wB;AACA,I;AACA,gB;AACA,K;;AAEA,mC;AACA,gB;AACA,wD;AACA,I;AACA,E;AACA,K;AACA,gF;AACA,gF;AACA,+E;AACA,uE;AACA,I;AACA,gB;AACA,K;AACA,oB;AACA,wB;AACA,I;;AAEA,K;AACA,0E;AACA,0E;AACA,mE;AACA,I;AACA,gB;AACA,K;;AAEA,4B;AACA,I;;AAEA,K;AACA,kE;AACA,0E;AACA,mE;AACA,I;AACA,gB;AACA,K;;AAEA,2B;AACA,I;;AAEA,K;AACA,+D;AACA,I;AACA,gB;AACA,K;;AAEA,8B;AACA,I;;AAEA,K;AACA,8D;AACA,I;AACA,gB;AACA,K;;AAEA,6B;AACA,G;AACA,E;;AAEA,2B;AACA,K;AACA,iC;AACA,I;AACA,yE;AACA,K;;AAEA,iC;AACA,gD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC5LA,G;AACA,8D;AACA,E;AACA,0B;AACA,sB;AACA,4B;AACA,c;AACA,G;;AAEA,iC;AACA,0B;;AAEA,K;AACA,oE;AACA,6B;AACA,I;AACA,gB;AACA,K;AACA,mB;;AAEA,K;AACA,6E;AACA,uE;AACA,I;AACA,iB;AACA,K;AACA,uB;;AAEA,K;AACA,sD;AACA,I;AACA,iB;AACA,K;AACA,mC;AACA,E;;;AAGA,wB;AACA,yB;;AAEA,0B;;AAEA,K;AACA,4E;AACA,wE;AACA,I;AACA,4B;AACA,yB;AACA,gB;AACA,K;;AAEA,iC;AACA,sC;AACA,oC;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,+C;AACA,I;AACA,a;AACA,8B;AACA,4B;AACA,S;AACA,I;AACA,0B;AACA,0B;AACA,iB;AACA,K;;AAEA,sB;AACA,wC;AACA,6D;AACA,kB;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,iE;AACA,I;AACA,+C;AACA,iE;AACA,+E;AACA,gF;AACA,uD;AACA,oB;AACA,gB;AACA,K;;AAEA,4C;AACA,c;;AAEA,yE;AACA,I;AACA,iC;AACA,sB;AACA,Q;AACA,sD;;AAEA,8B;AACA,4B;AACA,iB;AACA,I;;AAEA,K;AACA,+E;AACA,6B;AACA,I;AACA,a;AACA,qD;AACA,8D;AACA,yB;AACA,K;AACA,4D;AACA,iC;AACA,qB;AACA,gB;AACA,K;;AAEA,mC;AACA,sC;AACA,8C;AACA,4I;AACA,+C;AACA,I;;AAEA,K;AACA,wE;AACA,uC;AACA,I;AACA,a;AACA,qD;AACA,6D;AACA,mD;AACA,K;;AAEA,qC;AACA,yF;AACA,8C;AACA,I;;AAEA,K;AACA,2E;AACA,qE;AACA,gF;AACA,yE;AACA,qD;AACA,I;AACA,8C;AACA,wE;AACA,sE;AACA,0E;AACA,iC;AACA,gF;AACA,yE;AACA,+C;AACA,yB;AACA,gB;AACA,K;;AAEA,uD;AACA,mB;AACA,4B;AACA,a;AACA,qD;AACA,c;;AAEA,sB;AACA,0B;AACA,oD;;AAEA,mB;AACA,mD;AACA,O;;AAEA,6B;AACA,mC;AACA,4C;AACA,wD;AACA,oB;AACA,K;;AAEA,W;AACA,gB;AACA,I;;AAEA,K;AACA,8E;AACA,0E;AACA,8E;AACA,mF;AACA,6E;AACA,gF;AACA,gF;AACA,+E;AACA,mD;AACA,I;AACA,yB;AACA,yB;AACA,8B;AACA,sE;AACA,0E;AACA,iC;AACA,gF;AACA,yE;AACA,+C;AACA,yB;AACA,gB;AACA,K;;AAEA,yD;AACA,mB;AACA,e;AACA,kB;AACA,sD;;AAEA,yD;AACA,4E;;AAEA,+D;AACA,kD;AACA,6B;AACA,gD;;AAEA,2D;AACA,gE;;AAEA,4B;;AAEA,6C;;AAEA,mC;AACA,wB;AACA,2B;AACA,K;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,oB;AACA,I;AACA,+C;AACA,kD;AACA,oE;AACA,0C;AACA,I;AACA,2B;AACA,kC;AACA,8B;AACA,8B;AACA,iB;AACA,K;;AAEA,wD;AACA,e;AACA,uB;AACA,kB;AACA,c;AACA,kB;;AAEA,oC;AACA,wC;AACA,M;;AAEA,mD;AACA,oC;AACA,4C;AACA,8E;AACA,wB;AACA,M;;AAEA,sD;;AAEA,oD;AACA,6D;AACA,yD;AACA,mC;AACA,wB;AACA,K;;AAEA,wD;AACA,6B;AACA,wD;AACA,yE;AACA,yD;AACA,wB;AACA,K;;AAEA,0E;AACA,oD;;AAEA,oB;AACA,mE;;AAEA,4B;AACA,2D;AACA,0B;AACA,O;AACA,K;;AAEA,2D;AACA,iD;AACA,I;;AAEA,K;AACA,4E;AACA,8E;AACA,Y;AACA,I;AACA,wC;AACA,kC;AACA,iB;AACA,K;;AAEA,iD;AACA,mB;AACA,gC;;AAEA,uB;AACA,yB;AACA,uE;AACA,M;;AAEA,+E;AACA,iC;AACA,+B;;AAEA,8B;AACA,+B;AACA,Q;AACA,iC;;AAEA,kC;;AAEA,+E;AACA,sC;AACA,mC;AACA,I;AACA,yB;AACA,iC;;AAEA,8B;AACA,8B;AACA,Q;AACA,gC;;AAEA,kC;AACA,I;;AAEA,K;AACA,8E;AACA,yD;AACA,I;AACA,iD;AACA,iF;AACA,2B;AACA,gB;AACA,K;;AAEA,4B;AACA,wC;AACA,2B;AACA,U;AACA,0B;AACA,2B;AACA,K;AACA,I;;AAEA,K;AACA,yE;AACA,0E;AACA,uE;AACA,I;AACA,kC;AACA,8B;AACA,gB;AACA,K;;AAEA,sC;AACA,6C;AACA,I;;AAEA,K;AACA,0E;AACA,0E;AACA,6C;AACA,I;AACA,yB;AACA,8B;AACA,gB;AACA,K;;AAEA,yC;AACA,mD;AACA,I;;AAEA,K;AACA,6E;AACA,gF;AACA,4B;AACA,I;AACA,yB;AACA,8B;AACA,gB;AACA,K;;AAEA,6C;AACA,wD;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC5ZA,G;AACA,wE;AACA,E;AACA,+E;AACA,iD;AACA,E;AACA,c;AACA,oB;AACA,G;;AAEA,Y;AACA,uB;;AAEA,K;AACA,6C;AACA,I;AACA,iB;AACA,K;;AAEA,6B;;;AAGA,K;AACA,6E;AACA,I;AACA,iB;AACA,K;;AAEA,e;;AAEA,K;AACA,mD;AACA,I;AACA,0B;AACA,0B;AACA,wB;AACA,0E;AACA,iB;AACA,K;;AAEA,yD;AACA,wB;AACA,qB;AACA,wB;;AAEA,iD;AACA,wB;;AAEA,sC;AACA,8B;AACA,I;;AAEA,K;AACA,oE;AACA,I;AACA,iB;AACA,K;;AAEA,c;;AAEA,K;AACA,+E;AACA,Y;AACA,I;AACA,iB;AACA,K;AACA,mB;;AAEA,K;AACA,6C;AACA,I;AACA,gB;AACA,K;;AAEA,sB;AACA,wB;AACA,uB;AACA,I;;AAEA,K;AACA,yC;AACA,I;AACA,gB;AACA,K;;AAEA,yD;AACA,yC;AACA,oD;AACA,I;;AAEA,K;AACA,4C;AACA,I;AACA,gB;AACA,K;;AAEA,4D;AACA,4C;AACA,oD;AACA,I;;AAEA,K;AACA,0B;AACA,I;AACA,gB;AACA,K;;AAEA,qB;AACA,mB;AACA,I;;AAEA,K;AACA,6B;AACA,I;AACA,gB;AACA,K;;AAEA,wB;AACA,sB;AACA,I;;AAEA,K;AACA,wB;AACA,I;AACA,gB;AACA,K;AACA,sB;AACA,oB;AACA,I;;AAEA,K;AACA,mE;AACA,I;AACA,gB;AACA,K;;AAEA,sB;AACA,oB;;AAEA,+B;AACA,+B;;AAEA,oB;AACA,+C;AACA,M;AACA,I;AACA,oD;AACA,8C;AACA,O;;AAEA,0B;AACA,qE;AACA,I;;AAEA,K;AACA,4C;AACA,I;AACA,gB;AACA,K;;AAEA,qB;AACA,oD;AACA,iD;AACA,O;AACA,2B;AACA,I;;AAEA,K;AACA,oE;AACA,I;AACA,yB;AACA,sB;AACA,gB;AACA,K;;AAEA,iC;AACA,8D;AACA,uB;AACA,oC;AACA,qC;AACA,I;;AAEA,K;AACA,mD;AACA,I;AACA,uC;AACA,iB;AACA,K;;AAEA,4B;AACA,uE;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AChMA,G;AACA,8E;AACA,gD;AACA,E;AACA,e;AACA,E;AACA,G;;AAEA,0C;AACA,yD;AACA,yB;AACA,E;;AAEA,uC;;AAEA,kC;AACA,uB;AACA,kE;AACA,+B;AACA,I;;AAEA,4B;AACA,e;AACA,mB;AACA,sE;AACA,G;AACA,G;;AAEA,G;AACA,uE;AACA,6E;AACA,E;AACA,W;AACA,E;AACA,oC;AACA,E;AACA,+E;AACA,E;AACA,8B;AACA,2C;AACA,E;AACA,2C;AACA,qC;AACA,S;AACA,O;AACA,E;AACA,gB;AACA,G;;AAEA,gC;AACA,iB;AACA,oB;AACA,E;;AAEA,sC;AACA,gC;AACA,mB;AACA,gB;AACA,a;;AAEA,4B;;AAEA,2C;AACA,6D;;AAEA,8B;AACA,gC;;AAEA,+B;AACA,a;;AAEA,2B;;AAEA,gC;AACA,uB;AACA,M;;AAEA,+B;AACA,I;;AAEA,uB;AACA,oB;AACA,2C;AACA,yB;AACA,0B;AACA,+B;AACA,0B;AACA,I;;AAEA,yB;AACA,oB;AACA,Y;AACA,sC;AACA,U;AACA,gD;AACA,wC;AACA,S;AACA,K;AACA,I;;AAEA,+B;AACA,oB;;AAEA,8C;AACA,oB;AACA,I;;AAEA,8B;AACA,oB;AACA,iC;AACA,8C;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACjHA,G;AACA,sB;AACA,E;AACA,sB;AACA,wB;AACA,sB;AACA,G;;AAEA,+C;AACA,2B;;AAEA,K;AACA,iB;AACA,8B;AACA,2E;AACA,0E;AACA,W;AACA,K;;AAEA,mC;AACA,oB;;AAEA,8D;;AAEA,0C;;AAEA,4B;;AAEA,gC;AACA,8B;AACA,8C;AACA,4B;AACA,6C;AACA,uB;AACA,S;AACA,O;AACA,I;;AAEA,K;AACA,uC;AACA,I;AACA,4B;AACA,K;;AAEA,8B;;;AAGA,K;AACA,yE;AACA,gF;AACA,2E;AACA,4E;AACA,iB;AACA,I;AACA,wC;AACA,kC;AACA,8B;AACA,mB;AACA,K;;AAEA,kD;AACA,mB;AACA,kD;;AAEA,0C;AACA,uB;AACA,mC;AACA,qC;AACA,iC;AACA,kD;AACA,W;AACA,c;AACA,+B;AACA,gD;AACA,O;AACA,M;;AAEA,wD;AACA,8B;AACA,sC;AACA,2B;AACA,0B;AACA,S;AACA,M;;AAEA,8E;AACA,iC;AACA,oC;AACA,0C;AACA,Y;AACA,2B;AACA,K;AACA,I;;AAEA,K;AACA,+E;AACA,qE;AACA,I;AACA,c;AACA,I;AACA,8C;AACA,2D;AACA,I;AACA,oC;AACA,mC;AACA,4B;AACA,oC;AACA,gB;AACA,K;;AAEA,+D;AACA,6B;AACA,a;AACA,Y;AACA,a;AACA,kB;AACA,2B;AACA,2B;AACA,4E;AACA,gB;AACA,yE;AACA,S;AACA,Q;;AAEA,yC;AACA,6B;AACA,qB;AACA,2B;AACA,+D;AACA,wE;AACA,yE;AACA,yE;AACA,e;AACA,gD;AACA,Y;AACA,2C;AACA,2E;AACA,gC;AACA,kD;AACA,K;AACA,I;;AAEA,K;AACA,4E;AACA,+E;AACA,wE;AACA,I;AACA,uC;AACA,gB;AACA,K;;AAEA,uB;AACA,mB;AACA,c;AACA,sB;;AAEA,6C;AACA,0C;;AAEA,qB;AACA,wC;AACA,iB;;AAEA,iC;AACA,qB;;AAEA,mC;AACA,gD;AACA,6B;AACA,qB;AACA,kG;AACA,Y;AACA,kC;AACA,S;;AAEA,+B;AACA,+C;AACA,O;AACA,M;;AAEA,8E;AACA,2C;AACA,2B;;AAEA,yB;AACA,oC;AACA,sB;AACA,Y;AACA,mC;AACA,K;AACA,I;;AAEA,K;AACA,0E;AACA,8E;AACA,mB;AACA,I;AACA,gB;AACA,K;;AAEA,2B;AACA,uE;AACA,I;;;AAGA,K;AACA,2E;AACA,yD;AACA,I;AACA,gB;AACA,K;;AAEA,sB;AACA,oB;;AAEA,+B;;AAEA,0B;;AAEA,qD;AACA,kC;;AAEA,6E;AACA,oB;AACA,yC;AACA,I;AACA,+B;AACA,gB;AACA,oC;AACA,+B;AACA,gD;AACA,O;AACA,I;;AAEA,K;AACA,yE;AACA,I;AACA,gB;AACA,K;;AAEA,qB;AACA,2B;;AAEA,kC;AACA,uC;;AAEA,4B;AACA,oC;AACA,I;;AAEA,K;AACA,gE;AACA,I;AACA,gE;AACA,K;;AAEA,6B;AACA,gC;AACA,Y;AACA,a;;AAEA,8B;AACA,qB;AACA,qC;;AAEA,uC;AACA,e;;AAEA,oD;AACA,e;;AAEA,uC;AACA,e;;AAEA,uC;AACA,6B;;AAEA,oB;AACA,K;AACA,I;;AAEA,K;AACA,4E;AACA,wE;AACA,wC;AACA,I;AACA,yB;AACA,8B;AACA,gB;AACA,K;;AAEA,yC;AACA,gB;AACA,2B;AACA,G;AACA,G;;AAEA,G;AACA,wD;AACA,G;AACA,iB;;AAEA,G;AACA,uD;AACA,E;AACA,c;AACA,kB;AACA,G;;AAEA,0B;;;;;;;;;;;;;;;;;;;ACrTA,+G;;;;;;;;;;;;;;;;;;;ACAA,qC;AACA,2C;AACA,qB;AACA,oB;AACA,oB;;AAEA,qE;AACA,kE;;AAEA,oC;AACA,0B;AACA,6B;AACA,+B;AACA,sB;AACA,M;;AAEA,2D;AACA,6D;AACA,qC;AACA,gF;AACA,2D;AACA,yC;AACA,I;;AAEA,K;AACA,6E;AACA,4E;AACA,yE;AACA,Y;AACA,I;AACA,a;AACA,I;AACA,wB;AACA,kE;AACA,4C;AACA,O;AACA,I;AACA,wB;AACA,gB;AACA,K;;AAEA,wB;;AAEA,K;AACA,mC;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,iB;;AAEA,K;AACA,0E;AACA,0E;AACA,c;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,wB;;AAEA,K;AACA,qE;AACA,mE;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,yB;;AAEA,K;AACA,wE;AACA,e;AACA,I;AACA,4B;AACA,gB;AACA,K;;AAEA,W;;AAEA,K;AACA,8E;AACA,0E;AACA,+E;AACA,gF;AACA,+E;AACA,yE;AACA,0C;AACA,I;AACA,c;AACA,oB;AACA,gC;AACA,6C;AACA,uD;AACA,I;AACA,kC;AACA,gB;AACA,K;;AAEA,e;;AAEA,K;AACA,8E;AACA,0E;AACA,uB;AACA,I;AACA,c;AACA,oB;AACA,I;AACA,gC;AACA,I;AACA,iC;AACA,yB;AACA,iB;AACA,0E;AACA,2C;AACA,4C;AACA,I;AACA,mB;AACA,yC;AACA,mE;AACA,S;AACA,I;AACA,8E;AACA,kD;AACA,oE;AACA,6E;AACA,6E;AACA,+E;AACA,mB;AACA,uD;AACA,wD;AACA,gB;AACA,K;;AAEA,wC;AACA,Y;AACA,U;AACA,gB;AACA,wB;AACA,uB;AACA,c;AACA,oB;;AAEA,yD;AACA,yD;AACA,2C;AACA,S;;AAEA,a;AACA,M;AACA,I;AACA,4B;AACA,yC;AACA,yE;AACA,sE;;AAEA,oB;;AAEA,4C;AACA,0B;AACA,Q;AACA,uB;;AAEA,8C;AACA,8B;AACA,Q;AACA,2B;;AAEA,+B;AACA,kE;;AAEA,0E;AACA,0E;AACA,gD;AACA,oC;;AAEA,2D;AACA,+B;AACA,wB;AACA,c;AACA,S;AACA,M;;AAEA,8B;AACA,iC;AACA,uC;AACA,M;;AAEA,8E;AACA,+E;AACA,8E;AACA,4E;AACA,4C;AACA,8B;AACA,yC;AACA,O;AACA,I;;AAEA,K;AACA,gF;AACA,4E;AACA,qB;AACA,I;AACA,gB;AACA,K;;AAEA,oB;AACA,oB;;AAEA,kB;;AAEA,+B;AACA,iE;AACA,uC;AACA,S;AACA,K;AACA,I;;AAEA,K;AACA,gF;AACA,0E;AACA,gD;AACA,I;AACA,c;AACA,I;AACA,iE;AACA,4E;AACA,yC;AACA,I;AACA,uD;AACA,+E;AACA,8D;AACA,gB;AACA,K;;AAEA,6C;AACA,sB;AACA,oB;;AAEA,iB;AACA,gC;;AAEA,gC;AACA,mC;AACA,mB;AACA,wB;AACA,2E;AACA,K;;AAEA,4B;AACA,0B;;AAEA,uC;AACA,0B;AACA,wB;AACA,O;;AAEA,sC;AACA,4D;AACA,I;;AAEA,K;AACA,+E;AACA,4C;AACA,+B;AACA,8B;AACA,6D;AACA,wD;AACA,gB;AACA,K;;AAEA,0C;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACrRA,kD;AACA,a;;AAEA,4B;AACA,W;AACA,uB;AACA,Y;AACA,W;AACA,wB;AACA,iE;AACA,Y;AACA,W;AACA,oB;AACA,Y;AACA,Y;AACA,+C;AACA,G;;AAEA,qC;;AAEA,gB;AACA,C;;AAEA,iB;AACA,+E;AACA,kD;AACA,0C;AACA,K;;AAEA,8E;AACA,kD;AACA,yC;AACA,K;;AAEA,gE;AACA,4B;AACA,K;;AAEA,gE;AACA,sD;AACA,K;AACA,C","sourcesContent":["/*\nThe MIT License (MIT)\n\nCopyright (c) 2013 Chris Mather <mather@eventedmind.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n","/**\n * Utility methods available privately to the package.\n */\n\nRouterUtils = {};\n\n/**\n * Returns global on node or window in the browser.\n */\n\nRouterUtils.global = function () {\n  if (typeof window !== 'undefined')\n    return window;\n  else if (typeof global !== 'undefined')\n    return global;\n  else\n    return null;\n};\n\n/**\n * Given the name of a property, resolves to the value. Works with namespacing\n * too. If first parameter is already a value that isn't a string it's returned\n * immediately.\n *\n * Examples:\n *  'SomeClass' => window.SomeClass || global.someClass\n *  'App.namespace.SomeClass' => window.App.namespace.SomeClass\n *\n * @param {String|Object} nameOrValue\n */\n\nRouterUtils.resolveValue = function (nameOrValue) {\n  var global = RouterUtils.global()\n    , parts\n    , ptr;\n\n  if (_.isString(nameOrValue)) {\n    parts = nameOrValue.split('.')\n    ptr = global;\n    for (var i = 0; i < parts.length; i++) {\n      ptr = ptr[parts[i]];\n      if (!ptr)\n        throw new Error(parts.slice(0, i+1).join('.') + ' is ' + typeof ptr);\n    }\n  } else {\n    ptr = nameOrValue;\n  }\n\n  // final position of ptr should be the resolved value\n  return ptr;\n};\n\nRouterUtils.hasOwnProperty = function (obj, key) {\n  var prop = {}.hasOwnProperty;\n  return prop.call(obj, key);\n};\n\n/**\n * Don't mess with this function. It's exactly the same as the compiled\n * coffeescript mechanism. If you change it we can't guarantee that our code\n * will work when used with Coffeescript. One exception is putting in a runtime\n * check that both child and parent are of type Function.\n */\n\nRouterUtils.inherits = function (child, parent) {\n  if (RouterUtils.typeOf(child) !== '[object Function]')\n    throw new Error('First parameter to RouterUtils.inherits must be a function');\n   \n  if (RouterUtils.typeOf(parent) !== '[object Function]')\n    throw new Error('Second parameter to RouterUtils.inherits must be a function');\n\n  for (var key in parent) {\n    if (RouterUtils.hasOwnProperty(parent, key))\n      child[key] = parent[key];\n  }\n\n  function ctor () {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  child.__super__ = parent.prototype;\n  return child;\n};\n\nRouterUtils.toArray = function (obj) {\n  if (!obj)\n    return [];\n  else if (RouterUtils.typeOf(obj) !== '[object Array]')\n    return [obj];\n  else\n    return obj;\n};\n\nRouterUtils.typeOf = function (obj) {\n  if (obj && obj.typeName)\n    return obj.typeName;\n  else\n    return Object.prototype.toString.call(obj);\n};\n\nRouterUtils.extend = function (Super, definition) {\n  if (arguments.length === 1)\n    definition = Super;\n  else {\n    definition = definition || {};\n    definition.extend = Super;\n  }\n\n  return RouterUtils.create(definition, {delayInheritance: false});\n};\n\nRouterUtils.create = function (definition, options) {\n  var Constructor\n    , extendFrom\n    , savedPrototype;\n\n  options = options || {};\n  definition = definition || {};\n\n  if (RouterUtils.hasOwnProperty(definition, 'constructor'))\n    Constructor = definition.constructor;\n  else {\n    Constructor = function () {\n      if (Constructor.__super__ && Constructor.__super__.constructor)\n        return Constructor.__super__.constructor.apply(this, arguments);\n    }\n  }\n\n  extendFrom = definition.extend;\n\n  if (definition.extend) delete definition.extend;\n\n  var inherit = function (Child, Super, prototype) {\n    RouterUtils.inherits(Child, RouterUtils.resolveValue(Super));\n    if (prototype) _.extend(Child.prototype, prototype);\n  };\n\n  if (extendFrom) {\n    inherit(Constructor, extendFrom);\n  }\n\n  _.extend(Constructor.prototype, definition);\n\n  return Constructor;\n};\n\n/**\n * Assert that the given condition is truthy.\n *\n * @param {Boolean} condition The boolean condition to test for truthiness.\n * @param {String} msg The error message to show if the condition is falsy.\n */\n\nRouterUtils.assert = function (condition, msg) {\n  if (!condition)\n    throw new Error(msg);\n};\n\nRouterUtils.capitalize = function (str) {\n  return str[0].toUpperCase() + str.slice(1, str.length);\n};\n\nRouterUtils.classify = function (str) {\n  var re = /_|-|\\./;\n  return _.map(str.split(re), function (word) {\n    return RouterUtils.capitalize(word);\n  }).join('');\n};\n\n/**\n * Finds the given template in the Template namespace or returns the defaultFn\n * if no template is found in Template. If no defaultFn is provided and the\n * template is not found, throws an exception. In other words, ensures a\n * template function is returned.\n *\n * @param {String|Function} name The name of the template or the template\n * function itself.\n * @param {Function} [defaultFn] The default function to use if no template\n * function is found in the Template namespace.\n * @returns {Function}\n * @api private\n */\n\nRouterUtils.getTemplateFunction = function (name, defaultFn) {\n  var template = null;\n\n  if (_.isFunction(name))\n    template = name;\n  else if (_.isString(name))\n    template = Template[name];\n\n  if (!template && defaultFn)\n    template = defaultFn;\n\n  RouterUtils.assert(template, 'Template \"' + name + '\" not found');\n  return template;\n}\n","/**\n * Credit:\n *\n * The inspiration and some code for RoutePath comes from the page-js project:\n * https://github.com/visionmedia/page.js (MIT License), particularly the\n * compile method. RoutePath has been enhanced with a few features like the\n * ability to access the regular expression, and a few additional methods for\n * bidirectionally compiling and retrieving a path given some parameters.\n *\n */\n\n/**\n * Compiles a path with support for required, optional, wildcard and named\n * wildcard parameters. Also supports regular expression paths.\n *\n * Examples:\n *  \"/posts\"\n *  \"/posts/:_id\"\n *  \"/posts/:paramOne/:paramTwo\"\n *  \"/posts/:required/:optional?\"\n *  \"/posts/*\"\n *  \"/posts/:file(*)\"\n *  /^\\/commits\\/(\\d+)\\.\\.(\\d+)/\n *\n *  @constructor RoutePath\n *  @param {String|RegExp} path\n *  @param {Object} [options]\n *  @param {Boolean} [options.sensitive] Paths are case sensitive\n *  @param {Boolean} [options.strict] Truncate /? from path\n *  @api private\n */\n\nRoutePath = function (path, options) {\n  RouterUtils.assert(arguments.length >= 1,\n         'RoutePath constructor requires a path as the first parameter');\n\n  this.keys = [];\n  this.path = path || '';\n  this.options = options || {};\n};\n\nRoutePath.prototype = {\n  typeName: 'RoutePath',\n\n  constructor: RoutePath,\n\n  /**\n   * Compile the path. Typically you compile the path immediately after it is\n   * initialized, but this is not required. \n   *\n   *  @return {RoutePath}\n   *  @api public\n   */\n\n  compile: function () {\n    var self = this\n      , path\n      , options = self.options;\n\n    if (self.path instanceof RegExp) {\n      self.re = self.path;\n    } else {\n      path = self.path\n        .concat(options.strict ? '' : '/?')\n        .replace(/\\/\\(/g, '(?:/')\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional){\n            self.keys.push({ name: key, optional: !! optional });\n            slash = slash || '';\n            return ''\n              + (optional ? '' : slash)\n              + '(?:'\n              + (optional ? slash : '')\n              + (format || '') \n              + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n              + (optional || '');\n          }\n        )\n        .replace(/([\\/.])/g, '\\\\$1')\n        .replace(/\\*/g, '(.*)');\n      \n      self.re = new RegExp('^' + path + '$', options.sensitive ? '' : 'i');\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns an array of parameters given a path. The array may have named\n   * properties in addition to indexed values.\n   *\n   * @param {String} path\n   * @return {Array}\n   * @api public\n   */\n\n  params: function (path) {\n    if (!path) return null;\n\n    var params = []\n      , m = this.exec(path)\n      , queryString\n      , keys = this.keys\n      , key\n      , value;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      key = keys[i - 1];\n      value = typeof m[i] == 'string' ? decodeURIComponent(m[i]) : m[i];\n      if (key) {\n        params[key.name] = params[key.name] !== undefined ? \n          params[key.name] : value;\n      } else\n        params.push(value);\n    }\n\n    queryString = decodeURI(path).split('?')[1];\n\n    if (queryString) {\n      _.each(queryString.split('&'), function (paramString) {\n        paramParts = paramString.split('=');\n        params[paramParts[0]] = decodeURIComponent(paramParts[1]);\n      });\n    }\n\n    return params;\n  },\n\n  /**\n   * Returns true if the path matches and false otherwise.\n   *\n   * @param {String} path\n   * @return {Boolean} \n   * @api public\n   */\n  test: function (path) {\n    var qsIndex = path.indexOf('?')\n      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n    \n    return this.re.test(pathname);\n  },\n\n  /**\n   * Calls the exec method of the compiled path regular expression and returns\n   * the result.\n   *\n   * @param {String} path\n   * @return {Array|null}\n   * @api public\n   */\n  exec: function (path) {\n    var qsIndex = path.indexOf('?')\n      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n    return this.re.exec(pathname);\n  },\n\n  /**\n   * Given an object or array of params, returns a path. This is used to create\n   * Handlebars pathFor and urlFor helpers for example. If the params object has\n   * a 'query' property, its values are used as query params.\n   *\n   * @param {Object|Array} params\n   * @param {String|Object} [params.query] Query parameters to be appended to\n   * the path.\n   * @return {String}\n   * @api public\n   */\n  resolve: function (params) {\n    var value\n      , isValueDefined\n      , result\n      , wildCardCount = 0\n      , path = this.path\n      , query;\n\n    params = params || [];\n    query = params.query;\n\n    if (path instanceof RegExp) {\n      throw new Error('Cannot currently resolve a regular expression path');\n    } else {\n      path = this.path\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional) {\n            slash = slash || '';\n            value = params[key];\n            isValueDefined = typeof value !== 'undefined';\n\n            if (optional && !isValueDefined) {\n              slash = '';\n              value = '';\n            } else if (!isValueDefined) {\n              throw new Error(key + ' not found in params');\n            }\n\n            value = _.isFunction(value) ? value.call(params) : value;\n            return slash + encodeURIComponent(value);\n          }\n        )\n        .replace(\n          /\\*/g,\n          function (match) {\n            if (typeof params[wildCardCount] === 'undefined') {\n              throw new Error(\n                'You are trying to access a wild card parameter at index ' + \n                wildCardCount +\n                ' but the value of params at that index is undefined');\n            }\n\n            return encodeURIComponent(params[wildCardCount++]);\n          }\n        );\n\n      if (query) {\n        if (_.isObject(query)) {\n          query = _.map(_.pairs(query), function (queryPart) {\n            return queryPart[0] + '=' + encodeURIComponent(queryPart[1]);\n          }).join('&');\n        }\n\n        path = path + '?' + query;\n      }\n    }\n    \n    return path;\n  }\n};\n","/**\n * A simple object that gets created by the router and passed on to the route\n * handler. It has a reactive result method that can be used by the route\n * handler to trigger an invlidation somewhere. This is how the Router renders\n * routes to the page for example.\n *\n * @constructor RouteContext\n * @param {String} path\n * @param {IronRouter} router\n * @param {Route} route\n * @param {Object} [options]\n * @api private\n */\n\nRouteContext = function (path, router, route, options) {\n  RouterUtils.assert(typeof path === 'string', 'RouteContext requires path parameter');\n  RouterUtils.assert(router instanceof IronRouter, 'RouteContext requires router parameter');\n  RouterUtils.assert(route, 'RouteContext requires route parameter');\n\n  options = this.options = options || {}\n  this._deps = new Deps.Dependency;\n  this._result = null;\n  this.path = path;\n  this.router = router;\n  this.route = route;\n  this.state = options.state;\n  this.params = route.params(path);\n  this.action = route.action || 'run';\n  this.controller = route.controller;\n  this.isReactive = route.isReactive;\n};\n\nRouteContext.prototype = {\n  typeName: 'RouteContext',\n\n  constructor: RouteContext,\n\n  /**\n   * Returns an object that can be used to store state (e.g. pushState on the\n   * client). The object includes this.state and this.path\n   *\n   * @returns {Object}\n   * @api public\n   */\n\n  getState: function () {\n    return _.extend({}, this.state, {\n      path: this.path\n    });\n  }\n};\n","/**\n * Container class for route information.\n *\n * Example: \n *  new Route(router, 'postShow', {path: '/posts/:_id'});\n *  new Route(router, 'postShow', {path: '/posts/:_id'}, function () {});\n *  new Route(router, 'postShow', {path: '/posts/:_id', handler: function () {}});\n *\n * @constructor Route\n * @exports Route\n * @param {IronRouter} router\n * @param {String} name The name will be used as the default path if none is\n * specified in the options. For example, 'test' will become '/test'\n * @param {Object} [options]\n * @param {String} [options.path]\n * @param {Function} [options.handler]\n * @param {Function} [handler] Handler function can be passed as the last\n * parameter or as an option. A handler function is not required but will be\n * used by the Router if one is provided.\n * @api public\n */\n\nRoute = function (router, name, options, handler) {\n  var path;\n\n  RouterUtils.assert(router instanceof IronRouter);\n\n  RouterUtils.assert(_.isString(name),\n    'Route constructor requires a name as the second parameter');\n\n  if (_.isFunction(options))\n    options = { handler: options };\n\n  if (_.isFunction(handler))\n    options.handler = handler;\n\n  options = this.options = options || {};\n  path = options.path || ('/' + name);\n\n  this.router = router;\n  this.originalPath = path;\n  this.compiledPath = new RoutePath(path, options).compile();\n  this.name = name;\n  this.where = options.where || 'client';\n  this.handler = this.handler || options.handler;\n  this.action = options.action;\n  this.controller = options.controller;\n\n  if (typeof options.reactive !== 'undefined')\n    this.isReactive = options.reactive;\n  else\n    this.isReactive = true;\n};\n\nRoute.prototype = {\n  typeName: 'Route',\n\n  constructor: Route,\n\n  /**\n   * Returns true if the given path matches this route's compiled path. Proxies\n   * to the RoutePath instance stored in compiledPath.\n   *\n   * @param {String} path\n   * @return {Boolean}\n   * @api public\n   */\n\n  test: function (path) {\n    return this.compiledPath.test(path);\n  },\n\n  /**\n   * Returns an array or object of params given a path. Proxies to the RoutePath\n   * instance stored in compiledPath.\n   *\n   * @param {String} path\n   * @return {Array|Object}\n   * @api public\n   */\n\n  params: function (path) {\n    return this.compiledPath.params(path);\n  },\n\n  /**\n   * Returns a path given a params object or array. Proxies to the RoutePath\n   * instance stored in compiledPath.\n   *\n   * Example:\n   *  route = new Route(router, 'postShow', {path: '/posts/:id'});\n   *  route.path({id: 5}) => '/posts/5'\n   *\n   * @param {Array|Object} params\n   * @return {String}\n   * @api public\n   */\n\n  path: function (params) {\n    return this.compiledPath.resolve(params);\n  },\n\n  /**\n   * Returns an absolute url given a params object or array. Uses\n   * Meteor.absoluteUrl() for the root url.\n   *\n   * Example:\n   *  route = new Route(router, 'postShow', {path: '/posts/:id'});\n   *  route.url({id: 5}) => 'http://www.eventedmind.com/posts/5'\n   *\n   * @param {Array|Object} params\n   * @return {String}\n   * @api public\n   */\n\n  url: function (params) {\n    var path = this.path(params);\n    if (path[0] === '/')\n      path = path.slice(1, path.length);\n    return Meteor.absoluteUrl() + path;\n  }\n};\n","/**\n * Main class for handling data and rendering logic for a route.\n *\n * @constructor RouteController\n * @exports RouteController\n * @param {RouteContext} context\n * @param {Object} [options]\n * @param {String|Function} [options.template]\n * @param {String|Function} [options.loadingTemplate]\n * @param {String|Function} [options.notFoundTemplate]\n * @param {Object|Function} [options.data]\n */\n\nRouteController = function (context, options) {\n  var routerOptions\n    , routeOptions\n    , self = this;\n\n  RouterUtils.assert(context, 'RouteController requires a RouteContext');\n\n  options = this.options = options || {};\n\n  routerOptions = (context.router && context.router.options) || {};\n  routeOptions = (context.route && context.route.options) || {};\n\n  this.params = context.params || [];\n  this.route = context.route;\n  this.router = context.router;\n  this.context = context;\n\n  var getOption = function(name) {\n    return options[name]\n      || routeOptions[name]\n      || routerOptions[name] \n      || self[name];\n  };\n\n  this['onBeforeRun'] = getOption('onBeforeRun');\n  this['onAfterRun'] = getOption('onAfterRun');\n  this['onBeforeRerun'] = getOption('onBeforeRerun');\n  this['onAfterRerun'] = getOption('onAfterRerun');\n\n  this.stopped = false;\n  this.isFirstRun = true;\n\n  this.before = []\n    .concat(RouterUtils.toArray(routerOptions.before))\n    .concat(RouterUtils.toArray(routeOptions.before))\n    .concat(RouterUtils.toArray(options.before))\n    .concat(RouterUtils.toArray(this.before));\n\n  this.after = []\n    .concat(RouterUtils.toArray(routerOptions.after))\n    .concat(RouterUtils.toArray(routeOptions.after))\n    .concat(RouterUtils.toArray(options.after))\n    .concat(RouterUtils.toArray(this.after));\n\n  this.initialize(context, options);\n};\n\nRouteController.prototype = {\n  typeName: 'RouteController',\n\n  constructor: RouteController,\n\n  initialize: function (context, options) {\n    throw new Error('not implemented');\n  },\n\n  before: [],\n\n  /**\n   * After hooks to run after the controller action is called. The Router will\n   * typically call the runHooks method to call this function. This property is\n   * defined for inheritance. Each instance gets its own copy of after hooks at\n   * constructor time. This means that after hooks added to the prototype after\n   * constructor time will not be used in the instance.\n   */\n\n  after: [],\n\n  /**\n   * Run the hooks for the given name (e.g. before/after)\n   *\n   * @param {String} name The name of the hooks to run (e.g. before/after)\n   * @api public\n   */\n\n  runHooks: function (name) {\n    var self = this\n      , hooks = self[name];\n\n    if (!hooks) return;\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (this.stopped) break;\n      hooks[i].call(this);\n    }\n  },\n\n\n  /**\n   * The default action for the controller. Called by the Router. Calls the main\n   * render method and then the render method for each template specified in\n   * renderTemplates.\n   *\n   * @api public\n   */\n\n  run: function () {\n    throw new Error('not implemented');\n  },\n\n  /**\n   * Stop running this controller and redirect to a new path. Same parameters as\n   * those of Router.go.\n   *\n   * @api public\n   */\n\n  redirect: function (/* args */) {\n    this.stop();\n    return this.router.go.apply(this.router, arguments);\n  },\n  \n  /**\n   * Set the stopped property on the controller to true. This would typically be\n   * used in a before filter or hook. If the controller is marked as stopped, it\n   * tells the router not to call the controller's action or afterRun callbacks\n   * and hooks. This property is not used internally by the controller.\n   *\n   * @api public\n   */\n  stop: function() {\n    this.stopped = true;\n  },\n\n  /**\n   * Hook called on the before the first run - either the run method being\n   * called or another action being called. This method is called from the\n   * router. It should only be called once. Not on reactive reruns.\n   *\n   * @api public\n   */\n\n  onBeforeRun: function () {\n  },\n\n  /**\n   * Hook called after the first run - either the run method being\n   * called or another action being called. This method is called from the\n   * router. It should only be called once. Not on reactive reruns.\n   *\n   * @api public\n   */\n\n  onAfterRun: function () {\n  },\n\n  /**\n   * Hook called before a reactive rerun. Called by the router.\n   *\n   * @api public\n   */\n\n  onBeforeRerun: function () {\n  },\n\n  /**\n   * Hook called after a reactive rerun. Called by the router.\n   *\n   * @api public\n   */\n\n  onAfterRerun: function () {\n  }\n};\n\n_.extend(RouteController, {\n  /**\n   * Inherit from RouteController\n   *\n   * @param {Object} definition Prototype properties for inherited class.\n   */\n\n  extend: function (definition) {\n    return RouterUtils.extend(this, definition);\n  }\n});\n","/**\n * The main Router class which runs on both client and server.\n *\n * @constructor IronRouter\n * @exports IronRouter\n * @param {Object} [options]\n * @api public\n */\n\nIronRouter = function (options) {\n  this.configure(options);\n\n  /**\n   * The routes array which doubles as a named route index by adding\n   * properties to the array.\n   *\n   * @api public\n   */\n  this.routes = [];\n\n  /**\n   * The current context. This is set anytime a new route is dispatched. It's\n   * a reactive variable which you can get by calling Router.current();\n   *\n   * @api private\n   */\n  this._current = null;\n\n  /**\n   * Dependency to track dependencies on this._current\n   *\n   * @api private\n   */\n  this._deps = new Deps.Dependency;\n};\n\n\nIronRouter.prototype = {\n  typeName: 'IronRouter',\n\n  constructor: IronRouter,\n\n  /**\n   * Configure instance with options. This can be called at any time. If the\n   * instance options object hasn't been created yet it is created here.\n   *\n   * @param {Object} options\n   * @return {IronRouter}\n   * @api public\n   */\n\n  configure: function (options) {\n    this.options = this.options || {};\n    _.extend(this.options, options);\n    return this;\n  },\n\n  /**\n   * Convenience function to define a bunch of routes at once. In the future we\n   * might call the callback with a custom dsl.\n   *\n   * Example:\n   *  Router.map(function () {\n   *    this.route('posts');\n   *  });\n   *\n   *  @param {Function} cb\n   *  @return {IronRouter}\n   *  @api public\n   */\n\n  map: function (cb) {\n    RouterUtils.assert(_.isFunction(cb),\n           'map requires a function as the first parameter');\n    cb.call(this);\n    return this;\n  },\n\n  /**\n   * Define a new route. You must name the route, but as a second parameter you\n   * can either provide an object of options or a Route instance.\n   *\n   * @param {String} name The name of the route\n   * @param {Object} [options] Options to pass along to the route\n   * @param {Function} [handler] A handler function for the route. This usually\n   * isn't required as a handler is automatically created for you if one doesn't\n   * exist. Behavior is different on client and server.\n   * @return {Route}\n   * @api public\n   */\n\n  route: function (name, options, handler) {\n    var route;\n\n    RouterUtils.assert(_.isString(name), 'name is a required parameter');\n    \n    if (options instanceof Route)\n      route = options;\n    else\n      route = new Route(this, name, options, handler);\n\n    this.routes[name] = route;\n    this.routes.push(route);\n    return route;\n  },\n\n  /**\n   * Returns a path for a given routeName and params object. Used in Handlebars\n   * path helper for example.\n   *\n   * Example:\n   *  Router.route('postShow', {path: '/posts/:id'});\n   *  Router.path('postShow', {id: 5, query: {q: 'search'}) =>\n   *  '/posts/5?q=search'\n   * \n   * @param {String} routeName The name of the route to use.\n   * @param {Array|Object} params\n   * @return {String}\n   * @api public\n   */\n\n  //XXX fix up error handling here.\n  path: function (routeName, params) {\n    RouterUtils.assert(this.routes[routeName],\n     'You called Router.path for a route named ' + routeName + ' but that that route doesn\\'t seem to exist. Are you sure you created it?');\n    return this.routes[routeName].path(params);\n  },\n\n  /**\n   * Returns a full url for a given routeName and params object. Used in\n   * Handlebars url helper for example.\n   *\n   * Example:\n   *  Router.route('postShow', {path: '/posts/:id'});\n   *  Router.url('postShow', {id: 5, query: {q: 'search'}) =>\n   *  'http://www.eventedmind.com/posts/5?q=search'\n   */\n\n  url: function (routeName, params) {\n    RouterUtils.assert(this.routes[routeName], 'url: No route found named ' + routeName);\n    return this.routes[routeName].url(params);\n  },\n\n  /**\n   * Finds a route for the given path and runs it if found. If the route is\n   * found but is for a different environment (client vs. server) the\n   * onUnhandled function is called. If the route is not found at all (on client\n   * or server) the onRouteNotFound method is called. These functions are\n   * overridden on the client and server IronRouters.\n   *\n   * @param {String} path The path to dispatch\n   * @param {Object} [options] Options to pass along to the onRun method\n   * @param {Function} [cb] Optional callback to call if the path was \n   * successfully dispatched. Note that if a redirect occurs the original \n   * callback will not be called.\n   * @param {Function} [onUnhandled] Optional override for onUnhandled function.\n   * For example, the client router overrides this to unhook client event\n   * handlers and make a request to the server.\n   * @return {IronRouter}\n   * @api public\n   */\n\n  dispatch: function (path, options, cb, onUnhandled) {\n    var self = this\n      , routes = self.routes\n      , route\n      , where = Meteor.isClient ? 'client' : 'server'\n      , i = 0;\n\n    function next () {\n      route = routes[i++];\n      onUnhandled = onUnhandled || self.onUnhandled;\n\n      if (!route) {\n        return self.onRouteNotFound(path, options);\n      }\n\n      if (route.test(path)) {\n        if (route.where !== where) \n          return onUnhandled(path, options);\n        self.run(path, route, options, cb, onUnhandled);\n      } else next();\n    }\n\n    next();\n    return this;\n  },\n\n  /**\n   * Creates a new RouteContext and runs the given route for the given path by\n   * calling the onRun method of the router. After onRun completes, if the\n   * context hasn't changed in the mean time (i.e. the route handler calls run\n   * again before this function has completed), the deps.changed() method is called\n   * causing callers that are dependent on Router.current() to be rerun. This\n   * method also double checks that the given route is supposed to be run in the\n   * current environment (client or server). If not, the onUnhandled function of\n   * router is called. Typically, this method shouldn't be called directly. You\n   * should be calling the dispatch method instead.\n   *\n   * @param {String} path\n   * @param {Route} route\n   * @param {Object} [options]\n   * @param {Function} [cb] Optional callback to call if the path was \n   * successfully dispatched. Note that if a redirect occurs the original \n   * callback will not be called.\n   * @param {Function} [onUnhandled] Optional override for onUnhandled function.\n   * For example, the client router overrides this to unhook client event\n   * handlers and make a request to the server.\n   * @return {IronRouter}\n   * @api public\n   */\n\n  run: function (path, route, options, cb, onUnhandled) {\n    var self = this\n      , context\n      , controller\n      , where = Meteor.isClient ? 'client' : 'server';\n\n    RouterUtils.assert(path, 'You must run with a path');\n    RouterUtils.assert(route, 'You must provide a route to the run method');\n\n    // one last check to see if we should handle the route here\n    onUnhandled = onUnhandled || self.onUnhandled;\n    if (route.where != where)\n      onUnhandled && onUnhandled(path, options);\n\n    context = new RouteContext(path, this, route, options);\n    controller = this.getControllerForContext(context, options);\n\n    this._current = context;\n\n    this.onRun(controller, context, options);\n\n    if (context == this._current) {\n      cb && cb(context);\n      this._deps.changed();\n    }\n    return this;\n  },\n\n  /**\n   * Get a controller instance for the given action, context and options. There\n   * are four cases:\n   *\n   *  1) handler is defined directly on a route\n   *  2) controller option is defined on the route\n   *  3) intelligently find the controller class in global namespace\n   *  4) create a new anonymous controller\n   *\n   * @param {String} action\n   * @param {RouteContext} context\n   * @param {Object} [options]\n   * @return {RouteController}\n   * @api private\n   */\n\n  getControllerForContext: function (context, options) {\n    var handler\n      , controllerClass\n      , controller\n      , action\n      , routeName;\n\n    var classify = function (name) {\n      return RouterUtils.classify(name);\n    };\n\n    var getControllerFromWindow = function (name) {\n      var controller = window[name];\n      if (typeof controller === 'undefined')\n        throw new Error('controller \"' + name + '\" is not defined on window');\n      return controller;\n    };\n\n    action = context.action = context.action || 'run';\n\n    // case 1: handler defined directly on the route\n    if (handler = (context.route && context.route.handler)) {\n      controller = new RouteController(context, options);\n      controller[action] = handler;\n      return controller;\n    }\n\n    // case 2: controller option is defined on the route\n    if (context.controller) {\n      controllerClass = _.isString(context.controller) ?\n        getControllerFromWindow(context.controller) : context.controller;\n      controller = new controllerClass(context, options);\n      return controller;\n    }\n\n    // case 3: intelligently find the controller class in global namespace\n    routeName = context.route && context.route.name;\n\n    if (routeName) {\n      controllerClass = window[classify(routeName + 'Controller')];\n\n      if (controllerClass) {\n        controller = new controllerClass(context, options);\n        return controller;\n      }\n    }\n\n    // case 4: nothing found so create a default controller\n    return new RouteController(context, options);\n  },\n\n  /**\n   * Run a controller with a given context. Calls the before and after hooks\n   * and attaches to the onRender callback to render results into the router's\n   * layout.\n   *\n   * @param {RouteController} controller\n   * @param {RouteContext} context\n   * @api private\n   */\n\n  runController: function (controller, context) {\n    var self = this\n      , action = context.action;\n\n    RouterUtils.assert(\n      controller[action],\n      'No action \"' + action + '\" on controller ' + controller.typeName\n    );\n\n    // Since runController can be reactive, this resets the controller to a non\n    // stopped state on each run.\n    controller.stopped = false;\n\n    if (controller.isFirstRun)\n      controller.onBeforeRun();\n    else\n      controller.onBeforeRerun();\n\n    controller.runHooks('before');\n\n    // if the user stopped the controller in a before filter or hook then don't\n    // run the rest of the controller.\n    if (controller.stopped) return;\n    \n    controller[action]();\n    controller.runHooks('after');\n\n    if (controller.isFirstRun)\n      controller.onAfterRun();\n    else\n      controller.onAfterRerun();\n\n    controller.isFirstRun = false;\n  },\n\n  /**\n   * Reactive accessor for the current context. You can also get a nonreactive\n   * value by specifiying {reactive: false} as an option.\n   *\n   * @param {Object} [opts] configuration options\n   * @param {Boolean} [opts.reactive] Set to false to enable a non-reactive read.\n   * @return {RouteContext}\n   * @api public\n   */\n\n  current: function (opts) {\n    if (opts && opts.reactive === false)\n      return this._current;\n    else {\n      this._deps.depend();\n      return this._current;\n    }\n  },\n\n  /**\n   * Called by the run method to run a context which by this point should\n   * include the path and route. Should be overridden in client and server\n   * routers since the behavior will be different on client vs. server.\n   *\n   * @param {RouteContext} context\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onRun: function (context, options) {\n    throw new Error('onRun not implemented');\n  },\n\n  /**\n   * Called from the dispatch or run method when a route was found but not\n   * handled in the current environment (e.g. client or server). Should be\n   * overridden in client and server routers.\n   *\n   * @param {String} path\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onUnhandled: function (path, options) {\n    throw new Error('onUnhandled not implemented');\n  },\n\n  /**\n   * Called from the dispatch method when a route was not found for the given\n   * dispatched path. This method can be overridden in client and server routers\n   * but doesn't have to be.\n   *\n   * @param {String} path\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onRouteNotFound: function (path, options) {\n    throw new Error('No route found for path: ' + path);\n  }\n};\n","/**\n * Location singleton class for working with HTML5 pushState reactively.\n *\n * XXX Does not support pre IE10 since <ie10 doesn't support pushState. Need to\n * integrate history.js or handle hashes somehow.\n *\n * @api public\n * @exports Location\n */\n\nLocation = {\n  typeName: 'Location',\n\n  /**\n   * Track dependencies on the current state.\n   *\n   * @api private\n   */\n\n  _deps: new Deps.Dependency,\n\n\n  /**\n   * Reactive state property that gets set anytime the browser state changes.\n   *\n   * @api private\n   */\n\n  _state: null,\n\n  /**\n   * Set the current state and call deps.changed().\n   *\n   * @param {Object} state\n   * @param {String} title\n   * @param {String} url\n   * @param {Boolean} [skipReactive] Set the _state property unreactively.\n   * @api private\n   */\n\n  _setState: function (state, title, url, skipReactive) {\n    state = state || {};\n    state.path = url;\n    state.title = title;\n\n    if (EJSON.equals(this._state, state)) return;\n    this._state = state;\n\n    if (skipReactive === true) return;\n    else this._deps.changed();\n  },\n\n  /**\n   * Event map for adding and removing events during start and stop.\n   *\n   * @api private\n   */\n\n  _events: {},\n\n  /**\n   * Track whether Location has started yet - events wired up and listening for\n   * events.\n   *\n   * @api private\n   */\n  isStarted: false,\n\n  /**\n   * Reactive accessor for the current state.\n   *\n   * @api public\n   */\n\n  state: function () {\n    this._deps.depend();\n    return this._state;\n  },\n\n  /**\n   * Reactive proxy to history.pushState.\n   *\n   * @api public\n   */\n\n  pushState: function (state, title, url, skipReactive) {\n    history.pushState(state, title, url);\n    this._setState(state, title, url, skipReactive);\n  },\n\n  /**\n   * Reactive proxy to history.replaceState.\n   *\n   * @api public\n   */\n\n  replaceState: function (state, title, url, skipReactive) {\n    history.replaceState(state, title, url);\n    this._setState(state, title, url, skipReactive);\n  },\n\n  /**\n   * Proxy to history.back\n   *\n   * @api public\n   */\n\n  back: function () {\n    history.back();\n  },\n\n  /**\n   * Proxy to history.forward\n   *\n   * @api public\n   */\n\n  forward: function () {\n    history.forward();\n  },\n\n  /**\n   * Proxy to history.go\n   *\n   * @api public\n   */\n  go: function (arg) {\n    history.go(arg);\n  },\n\n  /**\n   * Start listening to pushState events and set the initial state.\n   *\n   * @api public\n   */\n\n  start: function () {\n    var self = this;\n\n    // only start Location once\n    if (self.isStarted) return;\n\n    self._events = {\n      'popstate': _.bind(this.onPopState, this)\n    };\n    \n    _.each(self._events, function (handler, event) {\n      addEventListener(event, handler, false);\n    });\n\n    self.isStarted = true;\n    self.replaceState({}, null, location.pathname + location.search);\n  },\n\n  /**\n   * Unhook events and mark isStarted false.\n   *\n   * @api public\n   */\n\n  stop: function () {\n    _.each(this._events, function (handler, event) {\n      removeEventListener(event, handler, false);\n    });\n    this.isStarted = false;\n  },\n\n  /**\n   * Returns true if href is of the same origin as the current page.\n   *\n   * @param {String} href\n   * @return {Boolean}\n   * @api public\n   */\n\n  isSameOrigin: function (href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) \n      origin += ':' + location.port;\n    return href.indexOf(origin) == 0;\n  },\n\n  /**\n   * Event handler for onpopstate. Calls _setState.\n   *\n   * @param {Object} e The event object\n   * @api private\n   */\n\n  onPopState: function (e) {\n    this._setState(e.state, null, location.pathname + location.search);\n  }\n};\n","/**\n * The main data structure for named yields. Stores a template and its data so\n * the template can be rendered at a later time.\n *\n * @api private\n *\n */\n\nYieldPartial = function (template, data) {\n  this.template = template || function () { return ''; };\n  this.data = data || {};\n};\n\nYieldPartial._DEFAULT_KEY = '__main__';\n\n_.extend(YieldPartial.prototype, {\n  render: function () {\n    var template = RouterUtils.getTemplateFunction(this.template);\n    return template(this.data);\n  },\n\n  equals: function (other) {\n    if (!other)\n      return false;\n    return this.template == other.template && this.data == other.data;\n  }\n});\n\n/**\n * A reactive dictionary of YieldPartials. The router gets and sets the\n * YieldPartial for a given named yield using an instance of this dictionary.\n *\n * Example:\n *\n *  var dict = new YieldPartialDict;\n *\n *  dict.set('aside', new YieldPartial('asideTemplate', { data: 'somedata' }));\n *\n *  Deps.autorun(function () {\n *    var yieldPartial = dict.get('aside');\n *\n *    var html = Spark.render(function () {\n *      return yieldPartial.render();\n *    });\n *  });\n *\n *  @api private\n */\n\nYieldPartialDict = function () {\n  this.keys = {};\n  this.keyDeps = {};\n};\n\n_.extend(YieldPartialDict.prototype, {\n  set: function (key, options) {\n    var self = this\n      , oldValue\n      , value\n\n    options = options || {};\n\n    key = key || YieldPartial._DEFAULT_KEY;\n    value = new YieldPartial(options.template, options.data);\n\n    if (_.has(self.keys, key))\n      oldValue = self.keys[key];\n\n    if (value.equals(oldValue))\n      return;\n\n    self.keys[key] = value;\n\n    var changed = function (v) {\n      v && v.changed();\n    };\n\n    changed(self.keyDeps[key]);\n  },\n\n  get: function (key) {\n    var self = this;\n    key = key || YieldPartial._DEFAULT_KEY;\n    self._ensureKey(key);\n    self._setDefault(key);\n    self.keyDeps[key].depend();\n    return self.keys[key];\n  },\n\n  clear: function (key) {\n    var self = this;\n    if (key)\n      self.set(key, new YieldPartial);\n    else {\n      _.each(_.keys(self.keys), function (key) {\n        self.set(key, new YieldPartial);\n      });\n    }\n  },\n\n  _setDefault: function (key) {\n    var self = this;\n\n    if (typeof self.keys[key] === 'undefined')\n      self.set(key);\n  },\n\n  _ensureKey: function (key) {\n    var self = this;\n    if (!(key in self.keyDeps)) {\n      self.keyDeps[key] = new Deps.Dependency;\n    }\n  }\n});\n","/**\n * Client side router.\n *\n * @class ClientRouter\n * @exports ClientRouter\n * @extends IronRouter\n */\n\nClientRouter = RouterUtils.extend(IronRouter, {\n  typeName: 'ClientRouter',\n\n  /**\n   * @constructor\n   * @param {Object} [options]\n   * @param {Boolean} [options.autoRender] Automatically render to the body\n   * @param {Boolean} [options.autoStart] Automatically start listening to\n   * events\n   */\n\n  constructor: function (options) {\n    var self = this;\n\n    ClientRouter.__super__.constructor.apply(this, arguments);\n\n    self._partials = new YieldPartialDict;\n\n    self.isRendered = false;\n\n    Meteor.startup(function () {\n      setTimeout(function () {\n        if (self.options.autoRender !== false)\n          self.autoRender();\n        if (self.options.autoStart !== false)\n          self.start();\n      });\n    });\n  },\n\n  /**\n   * The default layout for the router.\n   *\n   * @type {String|Function}\n   */\n\n  layout: '__defaultLayout__',\n\n\n  /**\n   * Hook method called from the Router's run method. This methods drives\n   * running the controller for a route. The controller can be run in a reactive\n   * or nonreactive context. If you pass options.reactive = false, then the\n   * controller will be run normally. Otherwise it will be run in a reactive\n   * computation.\n   *\n   * @param {RouteController} controller\n   * @param {RouteContext} context\n   * @param {Object} [options]\n   * @api protected\n   */\n\n  onRun: function (controller, context, options) {\n    var self = this\n      , isReactive = context.isReactive !== false;\n\n    var maybeRunReactively = function () {\n      if (isReactive) {\n        Deps.autorun(function (c) {\n          self._routeComputation = c;\n          self._partials.clear();\n          self.runController(controller, context);\n        });\n      } else {\n        self._partials.clear();\n        self.runController(controller, context);\n      }\n    };\n\n    controller.onRender = function (template, options) {\n      options = options || {};\n      self._partials.set(options.to, {\n        template: template,\n        data: options.data\n      });\n    };\n\n    // there is a route computation from a previous route so lets tear it down\n    if (self._routeComputation) {\n      self._routeComputation.stop();\n      Deps.afterFlush(maybeRunReactively);\n    } else {\n      maybeRunReactively();\n    }\n  },\n\n  /**\n   * Wrapper around Location.go that accepts a routeName or a path as the first\n   * parameter. This method can accept client and server side routes.\n   *\n   * Examples:\n   *\n   *  1. Router.go('/posts', {state: 'true'});\n   *  2. Router.go('postIndex', [param1, param2], {state});\n   *\n   * @param {String} routeNameOrPath\n   * @param {Array|Object} [params]\n   * @param {Object} [state]\n   * @param {Boolean} [replaceState]\n   * @api public\n   */\n\n  go: function (routeNameOrPath, params, state, replaceState) {\n    var isPathRe = /^\\/|http/\n      , route\n      , path\n      , state\n      , onComplete\n      , done = function() {\n        if (replaceState) {\n          Location.replaceState(state, null, path, true /* skipReactive */);\n        } else {\n          Location.pushState(state, null, path, true /* skipReactive */);\n        }\n      };\n\n    if (isPathRe.test(routeNameOrPath)) {\n      path = routeNameOrPath;\n      state = params;\n      replaceState = state;\n      // issue here is in the dispatch process we might want to\n      // make a server request so therefore not call this method yet, so\n      // we need to push the state only after we've decided it's a client\n      // request, otherwise let the browser handle it and send off to the\n      // server\n      this.dispatch(path, {state: state}, done);\n    } else {\n      route = this.routes[routeNameOrPath];\n      RouterUtils.assert(route, 'No route found named ' + routeNameOrPath);\n      path = route.path(params);\n      this.run(path, route, {state: state}, done);\n    }\n  },\n\n  /**\n   * Returns an html string or a document fragment with the router's layout.\n   * This method also sets up the 'yield' helper on the layout. This is so that\n   * the yield helper has a reference to the router through the closure.\n   *\n   * @returns {String|DocumentFragment}\n   * @api public\n   */\n\n  render: function () {\n    var self = this\n      , layout\n      , layoutHelpers;\n\n    layout = RouterUtils.getTemplateFunction(\n      this.options.layout || this.layout);\n\n    layoutHelpers = {\n      'yield': function (key, options) {\n        var html;\n\n        if (arguments.length < 2)\n          key = null;\n\n        function renderPartial () {\n          var partial = self._partials.get(key);\n          RouterUtils.assert(\n            partial, \n            'No yield named \"' + key + '\" found. Are you sure it\\'s in your main layout template?'\n          );\n          return partial.render();\n        }\n\n        html = renderPartial();\n        return new Handlebars.SafeString(html);\n      }\n    };\n\n    //XXX not convinced yet that we should throw an error if already rendered,\n    //but putting this in place now anyway.\n    self.isRendered = true;\n\n    if (layout.helpers) {\n      layout.helpers(layoutHelpers);\n      return layout();\n    } else {\n      return layout(layoutHelpers);\n    }\n  },\n\n  /**\n   * Render the router into the body of the page automatically. Calles the\n   * render method inside Spark.render to create a renderer and appends to the\n   * document body.\n   *\n   * @api public\n   */\n\n  autoRender: function () {\n    document.body.appendChild(Spark.render(_.bind(this.render, this)));\n  },\n\n\n  /**\n   * Start listening to click events and set up a Deps.autorun for location\n   * changes. If already started the method just returns.\n   *\n   * @api public\n   */\n\n  start: function () {\n    var self = this;\n\n    if (self.isStarted) return;\n\n    self.isStarted = true;\n\n    self._eventListener = new UniversalEventListener(\n      _.bind(self.onClick, self));\n\n    //XXX listener.installHandler(node, type) for A tags and children to make\n    //work with IE<8\n    self._eventListener.addType('click');\n    \n    Deps.autorun(function (c) {\n      var state;\n      self._locationComputation = c;\n      state = Location.state();\n      self.dispatch(state.path, {state: state});\n    });\n  },\n\n  /**\n   * Remove click event listener and stop listening for location changes.\n   *\n   * @api public\n   */\n\n  stop: function () {\n    this.isStarted = false;\n\n    if (this._locationComputation)\n      this._locationComputation.stop();\n\n    if (this._eventListener)\n      this._eventListener.destroy();\n  },\n\n  /**\n   * onclick event handler. Calls go for the path automatically.\n   *\n   * @param {Object} event Event object from the DOM click event\n   */\n\n  onClick: function (event) {\n    var el = event.currentTarget\n      , href\n      , path;\n\n    if (el.nodeName === 'A') {\n      href = el.href;\n      path = el.pathname + el.search;\n\n      if (event.isPropagationStopped())\n        return;\n\n      if (el.hash || el.getAttribute('href') == '#')\n        return;\n\n      if (!Location.isSameOrigin(href))\n        return;\n\n      event.stopImmediatePropagation();\n      event.preventDefault();\n\n      this.go(path);\n    }\n  },\n\n  /**\n   * If the route is unhandled on the client, try sending the request to the\n   * server. If instead the route is not found (on client or server) the\n   * IronRouter will throw an exception.\n   *\n   * @param {String} path\n   * @param {Object} [options]\n   * @api public\n   */\n\n  onUnhandled: function (path, options) {\n    this.stop();\n    window.location = path;\n  }\n});\n\n/**\n * Tell Location to start listening for pushState events\n */\nLocation.start();\n\n/**\n * The main Router instance that clients will deal with\n *\n * @api public\n * @exports Router\n */\n\nRouter = new ClientRouter;\n","Template.__define__(\"__defaultLayout__\",Package.handlebars.Handlebars.json_ast_to_func([[\"{\",[[0,\"yield\"]]]]));\n","_.extend(RouteController.prototype, {\n  initialize: function (context, options) {\n    var routerOptions\n      , routeOptions\n      , self = this;\n\n    routerOptions = (context.router && context.router.options) || {};\n    routeOptions = (context.route && context.route.options) || {};\n\n    var getOption = function(name) {\n      return options[name]\n        || routeOptions[name]\n        || routerOptions[name] \n        || self[name];\n    };\n\n    this['loadingTemplate'] = getOption('loadingTemplate');\n    this['notFoundTemplate'] = getOption('notFoundTemplate');\n    this['data'] = getOption('data');\n    this['template'] = getOption('template') || (this.route && this.route.name);\n    this['renderTemplates'] = getOption('renderTemplates');\n    this['waitOn'] = getOption('waitOn');\n  },\n\n  /**\n   * Used to specify additional templates to render into named yield regions.\n   * The default run method will first render the main template and then use\n   * this property to render additional templates. Only used in the 'run'\n   * method.\n   *\n   * Example:\n   *\n   *  renderTemplates: {\n   *    'asideTemplateName': {to: 'aside', data: {}, waitOn: Sub},\n   *    'footerTemplateName': {to: 'footer'}\n   *  }\n   *\n   * @type {Object|null}\n   * @api public\n   */\n\n  renderTemplates: null,\n\n  /**\n   * The default template to render\n   *\n   * @type {String|Function}\n   * @api public\n   */\n\n  template: null,\n\n  /**\n   * Optional template to be used while waiting. If specified, the loading\n   * template is used automatically in the run method. You can also use it\n   * manually.\n   *\n   * @type {String|Function}\n   * @api public\n   */\n\n  loadingTemplate: null,\n\n  /**\n   * Optional template to be used if data returns a falsy value. Used\n   * automatically in the run method. You can also use it manually.\n   *\n   * @type {String|Function}\n   * @api public\n   */\n\n  notFoundTemplate: null,\n\n  /**\n   * A default data object or function to be used as the data context in\n   * rendering.\n   *\n   * @type {Object|Function}\n   * @api public\n   */\n\n  data: {},\n\n  /**\n   * Wait on one or more subscriptions. Actually, anything with a ready method\n   * will work. Handles defined here will be used automatically in the run\n   * method to wait on certain subscriptions before rendering. It can be useful\n   * when the data is required to determine whether to render the page. This can\n   * be overridden by passing a waitOn option to the render method. If you want\n   * to delay evaluation you can provide a function instead that won't be\n   * executed at controller creation time.\n   *\n   * Examples:\n   *  waitOn: handle\n   *  waitOn: [handle1, handle2]\n   *  waitOn: function () { return handle1; }\n   *  waitOn: function () { return [handle1, handle2] }\n   *\n   * @type {Array|Object|Function}\n   * @api public\n   */\n\n  waitOn: null,\n\n  /**\n   * Calls the onRender method with a template function, data and to property.\n   * The to property is for named yields. This method also handles waiting\n   * (waitOn) and data.\n   *\n   * Examples:\n   *  this.render();\n   *\n   *  this.render('myTemplate');\n   *\n   *  this.render('myTemplate', {\n   *    to: 'namedYield',\n   *    data: {},\n   *    waitOn: subHandle, // or waitOn: function () { return subHandle; }\n   *    loadingTemplate: 'loadingTemplate',\n   *    notFoundTemplate: 'notFoundTemplate'\n   *\n   *  this.render({\n   *    'asideTemplate': { to: 'aside' },\n   *    'mainTemplate': { to: '__main__' } // or just call render()\n   *  });\n   *\n   * @param {String|Function|Object} [template] Optional template to render or\n   * an object (map) of templates to named yields.\n   * @param {Object} [options] Render options for a single template.\n   * @param {String} [options.to] Render the template to a given named yield.\n   * @param {Array|Object} [options.waitOn] Wait on one or more subscriptions\n   * before rendering. If the loadingTemplate is defined then render that while\n   * we're waiting.\n   * @param {String|Function} [options.loadingTemplate]\n   * @param {String|Function} [options.notFoundTemplate]\n   * @api public\n   */\n\n  render: function (template, options) {\n    var data\n      , to\n      , template\n      , notFoundTemplate\n      , loadingTemplate\n      , waitOn\n      , self = this;\n\n    if (_.isObject(template) && arguments.length === 1) {\n      _.each(template, function (options, templateName) {\n        self.render(templateName, options);\n      });\n\n      return;\n    } \n    \n    options = options || {};\n    template = template || this.template;\n    notFoundTemplate = options.notFoundTemplate || this.notFoundTemplate;\n    loadingTemplate = options.loadingTemplate || this.loadingTemplate;\n\n    to = options.to;\n\n    if (typeof options.data !== 'undefined')\n      data = options.data;\n    else\n      data = this.data;\n\n    if (typeof options.waitOn !== 'undefined')\n      waitOn = options.waitOn;\n    else\n      waitOn = this.waitOn;\n\n    var onReady = function () {\n      var dataValue = _.isFunction(data) ? data.call(self) : data;\n\n      // if this is the main template and data returned null and we have a\n      // notFoundTemplate then render that instead of the regular template\n      if (!dataValue && notFoundTemplate && !to)\n        template = notFoundTemplate;\n\n      // give the router a chance to do something with this\n      self.onRender(template, {\n        data: dataValue,\n        to: to\n      });\n    };\n\n    var onWait = function () {\n      if (loadingTemplate && !to)\n        self.onRender(loadingTemplate);\n    };\n\n    // wait requires an autorun. also, this isolates the data function to only\n    // affect the current call to render and not the enclosing function. if you\n    // use a reactive data source in the enclosing function (the action or run\n    // method) that method is run in its own computation, unless you specify\n    // reactive: false in the route options.\n    Deps.autorun(function () {\n      self.wait(waitOn, onReady, onWait);\n    });\n  },\n\n  /**\n   * The default action for the controller. Called by the Router. Calls the main\n   * render method and then the render method for each template specified in\n   * renderTemplates.\n   *\n   * @api public\n   */\n\n  run: function () {\n    var self = this;\n\n    self.render();\n\n    if (self.renderTemplates) {\n      _.each(self.renderTemplates, function (options, template) {\n        self.render(template, options);\n      });\n    }\n  },\n\n  /**\n   * Wait on one or more subscriptions. Must be run in a reactive computation in\n   * order to work property. Calls the onReady method when all handles are\n   * ready. Otherwise calls the onWait function.\n   *\n   * Examples:\n   *\n   *  this.wait(function () { return handle; }, onReady, onWait);\n   *  this.wait(function () { return [handle1, handle2]}, onReady, onWait );\n   *  this.wait(handle, onReady, onWait);\n   *\n   * @param {Array|SubscriptionHandle|Function} handles\n   * @param {Function} onReady Function to be called when all handles are ready\n   * @param {Function} [onWait] Function to call while waiting\n   * @api public\n   */\n\n  wait: function (handles, onReady, onWait) {\n    var isReady = true\n      , self = this;\n\n    if (!handles)\n      return onReady.call(this);\n\n    if (_.isFunction(handles)) {\n      handles = handles.call(self);\n      if (!handles)\n        throw new Error(\n          'It looks like your waitOn function is not returning anything!');\n    }\n\n    if (!_.isArray(handles))\n      handles = [handles];\n\n    _.each(handles, function (handle) {\n      if (!handle.ready())\n        isReady = false;\n    });\n\n    onWait = onWait || function () {};\n    return isReady ? onReady.call(this) : onWait.call(this);\n  },\n\n  /**\n   * Hook for Router to attach itself to the result of a render. This is called\n   * by the render method one or more times.\n   * @param {Function} template\n   * @param {Object} [options]\n   * @param {Object|Function} [options.data] The data context\n   * @param {String} [options.to] The named yield region\n   * @api public\n   */\n\n  onRender: function (template, options) {\n  }\n});\n","function getParams (routeName, context, options) {\n  var params;\n\n  switch(arguments.length) {\n    case 3:\n      params = context;\n      break;\n    case 2:\n      options = context;\n      params = _.keys(options.hash).length ? options.hash : this;\n      break;\n    case 1:\n      params = this;\n      break;\n    default:\n      throw new Error('No routeName provided');\n  }\n\n  if (params === window) params = [];\n\n  return params;\n}\n\nif (Handlebars) {\n  Handlebars.registerHelper('pathFor', function (routeName, context, options) {\n    var params = getParams.apply(this, arguments);\n    return Router.path(routeName, params);\n  });\n\n  Handlebars.registerHelper('urlFor', function (routeName, context, options) {\n    var params = getParams.apply(this, arguments);\n    return Router.url(routeName, params);\n  });\n\n  Handlebars.registerHelper('currentRoute', function (options) {\n    return Router.current();\n  });\n\n  Handlebars.registerHelper('renderRouter', function (options) {\n    return new Handlebars.SafeString(Router.render());\n  });\n}\n"]}